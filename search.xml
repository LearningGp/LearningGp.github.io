<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>212 单词搜索Ⅱ</title>
    <url>/2020/06/01/212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%E2%85%A1/</url>
    <content><![CDATA[<h1 id="单词搜索ii">212 单词搜索II</h1>
<p>难度：困难</p>
<p>平台：leetcode</p>
<h2 id="description">Description</h2>
<p>给定一个二维网格 <strong>board</strong> 和一个字典中的单词列表 <strong>words</strong>，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p><strong>示例:</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line"> [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],</span><br><span class="line"> [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],</span><br><span class="line"> [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],</span><br><span class="line"> [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出:[&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure> <strong>说明:</strong><br />
你可以假设所有输入都由小写字母 <code>a-z</code> 组成。<br />
<a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="mysolution">MySolution</h2>
<p>这类字符串多模式匹配题目，第一反映是前缀树，关于前缀树在这里就不过多介绍了。此题基本思路是，将words字符串数组构造成前缀树，然后对board的每个字符用前缀树去匹配。当时做这道题花了一定的时间主要是因为用前缀树去匹配时涉及状态回溯，要在每次失败或者结束后回到上一个状态，并且不可遗漏，一开始写题时没有考虑周到。接下来上拆解代码。 ### 结点定义 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</span><br><span class="line">    <span class="comment">//节点结构</span></span><br><span class="line">    ArrayList&lt;node&gt; nodes=<span class="keyword">new</span> ArrayList&lt;node&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">boolean</span> isEnd, <span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造前缀树">构造前缀树</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造前缀树</span></span><br><span class="line">    <span class="keyword">for</span>(String s:words) &#123;</span><br><span class="line">        Solution.node cur=root;</span><br><span class="line">        <span class="keyword">char</span>[] a=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(Solution.node n:cur.nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span>(n.value==a[i]) &#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                        n.isEnd=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cur=n;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                    cur.nodes.add(<span class="keyword">new</span> Solution.node(<span class="keyword">false</span>, a[i]));</span><br><span class="line">                    cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.nodes.add(<span class="keyword">new</span> Solution.node(<span class="keyword">true</span>, a[i]));</span><br><span class="line">                    cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前缀树匹配">前缀树匹配</h3>
<p>前缀树匹配时采用递归+回溯的思想 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,node cur,<span class="keyword">int</span>[][] visited,String rString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp;j&lt;n &amp;&amp; visited[i][j]!=<span class="number">1</span>) <span class="comment">//判断边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(node n:cur.nodes) <span class="comment">//遍历当前节点子结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(boards[i][j]!=n.value) <span class="comment">//子节点未找到相同字母</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//子节点找到相同字母</span></span><br><span class="line">            &#123;</span><br><span class="line">                rString+=boards[i][j];<span class="comment">//添加到结果String</span></span><br><span class="line">                <span class="keyword">if</span> (n.isEnd) <span class="comment">//添加到结果String集</span></span><br><span class="line">                    result.add(rString);</span><br><span class="line">                cur=n;<span class="comment">//子节点变成当前结点</span></span><br><span class="line">                <span class="keyword">if</span>(n.nodes.isEmpty()) &#123;</span><br><span class="line">                    visited[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">                    find(i+x[k], j+y[k], cur, visited, rString);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//查询四周</span></span><br><span class="line">                visited[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子节点内无相同结点</span></span><br><span class="line">        visited[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="整体代码">整体代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    node root=<span class="keyword">new</span> node(<span class="keyword">false</span>, <span class="string">'*'</span>);</span><br><span class="line">    <span class="keyword">char</span>[][] boards;</span><br><span class="line">    Set&lt;String&gt; result=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] x= &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//负责向四周移动</span></span><br><span class="line">    <span class="keyword">int</span>[] y= &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//负责向四周移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造前缀树</span></span><br><span class="line">        <span class="keyword">for</span>(String s:words) &#123;</span><br><span class="line">            node cur=root;</span><br><span class="line">            <span class="keyword">char</span>[] a=s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(node n:cur.nodes) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(n.value==a[i]) &#123;</span><br><span class="line">                        flag=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i==a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                            n.isEnd=<span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            cur=n;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i!=a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                        cur.nodes.add(<span class="keyword">new</span> node(<span class="keyword">false</span>, a[i]));</span><br><span class="line">                        cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cur.nodes.add(<span class="keyword">new</span> node(<span class="keyword">true</span>, a[i]));</span><br><span class="line">                        cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,node cur,<span class="keyword">int</span>[][] visited,String rString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp;j&lt;n &amp;&amp; visited[i][j]!=<span class="number">1</span>) <span class="comment">//判断边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            visited[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(node n:cur.nodes) <span class="comment">//遍历当前节点子结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(boards[i][j]!=n.value) <span class="comment">//子节点未找到相同字母</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//子节点找到相同字母</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//访问标记</span></span><br><span class="line">                    rString+=boards[i][j];<span class="comment">//添加到结果String</span></span><br><span class="line">                    <span class="keyword">if</span> (n.isEnd) <span class="comment">//添加到结果String集</span></span><br><span class="line">                        result.add(rString);</span><br><span class="line">                    cur=n;<span class="comment">//子节点变成当前结点</span></span><br><span class="line">                    <span class="keyword">if</span>(n.nodes.isEmpty()) &#123;</span><br><span class="line">                        visited[i][j]=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">                        find(i+x[k], j+y[k], cur, visited, rString);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//查询四周</span></span><br><span class="line">                    visited[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子节点内无相同结点</span></span><br><span class="line">            visited[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        init(words);</span><br><span class="line">        boards=board;</span><br><span class="line">        m=boards.length;</span><br><span class="line">        n=boards[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[][] visited=<span class="keyword">new</span> <span class="keyword">int</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">                String rString=<span class="string">""</span>;</span><br><span class="line">                find(i,j,root,visited,rString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; ans=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String string : result) &#123;</span><br><span class="line">            ans.add(string);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</span><br><span class="line">        <span class="comment">//节点结构</span></span><br><span class="line">        ArrayList&lt;node&gt; nodes=<span class="keyword">new</span> ArrayList&lt;node&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">char</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">boolean</span> isEnd, <span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有的没的">有的没的</h2>
<p>这一分类主要记录自己做过的一些还比较有意义的题目的解题历程以及一些个人思考，菜鸡起步而已，希望自己能坚持下去，然后能有所进步吧。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>前缀树</tag>
        <tag>困难</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day01</title>
    <url>/2020/08/06/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day01/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day01">ECS 7天实践训练营@day01</h1>
<h2 id="有的没的">有的没的</h2>
<p>最近也是算空闲在家，所以希望能多学点东西，同时期在学习的内容包括网络爬虫、数据分析等，但是觉得内容需要等边学边写到一定阶段后整理个合集在放到博客上，所以这个博客也有一段时间没有更新，东西在写，之后见面。<br />
ECS 7天实践训练营是由阿里云高校计划发起的帮助学生熟悉云上实践的项目，目前个人有一个博客，一个私有网盘跑在云上，希望能探索更多的实践用法，而且加上自己这方面的知识确实比较匮乏，所以报名了这个训练营。<br />
目前第一天体验下来，感觉训练营的课程很详细很实用，确实能让我学习到很多东西，希望自己能继续坚持。</p>
<h2 id="搭建自己专属的静态网站与云笔记">搭建自己专属的静态网站与云笔记</h2>
<p>这是第一天的学习内容，课程主要讲解了两种方案，加上个人在使用的这种方案，接下来对这三种比较容易上手的方案做最粗浅的介绍。</p>
<h3 id="方案一-vuepress">方案一 VuePress</h3>
<h4 id="介绍">介绍</h4>
<p>VuePress是基于Vue的静态网站生成器，主要用于生成技术文档。<br />
主要优点有：</p>
<ul>
<li>界面简洁优雅</li>
<li>容易上手</li>
<li>兼容markdown语法</li>
<li>发布时间新，插件以及主题丰富（个人意见）</li>
</ul>
<h4 id="部署步骤">部署步骤</h4>
<h5 id="开通云服务器">开通云服务器</h5>
<p>本次使用的阿里云的服务器，开通流程非常流畅，基本是跟着指示走即可。需要注意的点有</p>
<ul>
<li>系统尽量选择Centos7，使用范围广，在出现问题时便于查询解决方案</li>
<li>需要在安全组开放用于SSH登录的22端口以及之后网站需要的8080端口</li>
</ul>
<h5 id="安装node.js">安装Node.js</h5>
<ol type="1">
<li><p>登录云服务器，Windows环境下个人推荐Xshell</p></li>
<li><p>通过淘宝镜像下载Node.js 13.9.0 64位安装包（加速下载） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;v13.9.0&#x2F;node-v13.9.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></p></li>
<li><p>安装及配置 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 创建安装目录</span><br><span class="line">sudo mkdir -p &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs</span><br><span class="line">2 将⼆进制⽂件解压到要安装⽬录</span><br><span class="line">sudo tar -xJvf node-v13.9.0-linux-x64.tar.xz -C &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs</span><br><span class="line">3 使⽤查看node.js版本号命令验证是否解压成功</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs&#x2F;node-v13.9.0-linux-x64&#x2F;bin</span><br><span class="line">.&#x2F;node -v</span><br><span class="line">4 修改环境变量量，使得能在任意⽬目录下执⾏行行node命令</span><br><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line">在PATH&#x3D;$PATH:$HOME&#x2F;bin 后⾯面添加路径:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs&#x2F;node-v13.9.0-linux-x64&#x2F;bin</span><br><span class="line">5 其他路径下验证</span><br><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h5 id="安装vuepress">安装VuePress</h5>
<ol type="1">
<li><p>全局安装（采⽤淘宝镜像） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm install -g vuepress</span><br></pre></td></tr></table></figure></p></li>
<li><p>创建目录 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir try_blogs</span><br><span class="line">cd try_blogs</span><br></pre></td></tr></table></figure></p></li>
<li><p>初始化项目 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure> 目录结构 <img src="/2020/08/06/ECS-7天实践训练营-day0/Ms.png" alt="LearningGp" /></p></li>
</ol>
<h5 id="配置vuepress">配置VuePress</h5>
<ol type="1">
<li><p>修改package.json，将scripts内容修改如下 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">	"docs:dev": "vuepress dev docs",</span><br><span class="line">    "docs:build": "vuepress build docs"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p></li>
<li><p>根据目录结构创建相关目录及文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir docs</span><br><span class="line">cd docs</span><br><span class="line">mkdir .vuepress</span><br><span class="line">echo &#39;# Hello VuePress - first blog!&#39; &gt;README.md</span><br><span class="line">cd .vuepress</span><br><span class="line">echo &gt;config.js</span><br><span class="line">mkdir public</span><br></pre></td></tr></table></figure></p></li>
<li><p>回到try_blogs⽬录，执行命令vuepress dev docs</p></li>
</ol>
<ul>
<li>vuepress dev docs 命令运⾏本地服务，通过访问(http://localhost:8080)即可预览⽹站</li>
<li>vuepress build docs 命令⽤来⽣成静态⽂件， 默认情况下， 放置在docs/.vuepress/dist⽬录中，当然你也可以在docs/.vuepress/config.js中的dest字段来修改默认存放⽬录。</li>
</ul>
<ol start="4" type="1">
<li><p>在浏览器中运⾏：http://ECS公⽹IP:8080。现实如下成功 <img src="/2020/08/06/ECS-7天实践训练营-day0/successed1.png" alt="LearningGp" /></p></li>
<li><p>配置首页，修改READAME.d，将内容改为下图 <img src="/2020/08/06/ECS-7天实践训练营-day0/peizhi.png" alt="LearningGp" /> 刷新浏览器得到新的首页 <img src="/2020/08/06/ECS-7天实践训练营-day0/index2.png" alt="LearningGp" /></p></li>
</ol>
<h3 id="方案二-wordpress">方案二 WordPress</h3>
<h4 id="介绍-1">介绍</h4>
<p>基于 ECS（云服务器）+ CentOS（操作系统）环境，通过部署 LAMP环境并安装 WordPress 快速搭建个人博客。   主要优点有 - 界面简洁优雅 - 容易上手 - 兼容markdown语法 - 自带完善方便的管理界面</p>
<h4 id="部署步骤-1">部署步骤</h4>
<p>阿里云给出了完整的入门场景体验，可以点击链接了解<br />
<a href="https://developer.aliyun.com/adc/scenario/fdecd528be6145dcbe747f0206e361f3?spm=5176.14319553.J_8315879550.2.3c2413bfKDFSk9" target="_blank" rel="noopener">体验链接</a></p>
<figure>
<img src="/2020/08/06/ECS-7天实践训练营-day0/index3.png" alt="" /><figcaption>首页</figcaption>
</figure>
<h3 id="方案三-hexogithub">方案三 Hexo+GitHub</h3>
<h4 id="介绍-2">介绍</h4>
<p>这是我目前使用的方案，也就是这个博客所使用的方案。优点与上两种大致相似，不过由于发布时间较早，现在使用起来有种种小问题需要自行解决，较为麻烦。目前博客集成了浏览统计，文章置顶，next主题，评论功能，后台管理，便签分类等插件。暂时运行良好，不过通过这次学习，正在考虑换成方案一，故在此不再赘述部署步骤等。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>VuePress</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day02</title>
    <url>/2020/08/07/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day02/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day02">ECS 7天实践训练营@day02</h1>
<h2 id="有的没的">有的没的</h2>
<p>第二天的内容是搭建wiki知识库，就是搭建一个私人百科，之前也没有想到过这个想法，不过确实是有实用价值的。课程讲解的很清楚，基本上跟着走就可以完成。不过这个应用对于我个人暂时还没有应用的场景，暂且把搭建方法留存下来备用。</p>
<h2 id="搭建wiki知识库">搭建wiki知识库</h2>
<h3 id="开通云服务器">开通云服务器</h3>
<p>同样采用阿里云的ECS并在安全组中开放http80端口，https443端口，ssh22端口。</p>
<h3 id="安装运行环境">安装运行环境</h3>
<p>这里课程采用的方案是从镜像市场下载LAMP环境（Ubuntu16.04 Apache PHP7.1）镜像，实际操作时没搜到这个，所以用了 LAMP环境（Ubuntu 18.04 Apache PHP7.1）代替。<br />
在阿里云平台上部署镜像有三种方式：</p>
<ul>
<li>购买时直接部署镜像 <img src="/2020/08/07/ECS-7天实践训练营-day0/1.png" alt="LearningGp" /></li>
<li>停止实例后更换操作系统 <img src="/2020/08/07/ECS-7天实践训练营-day0/2.png" alt="LearningGp" /></li>
<li>在<a href="https://market.aliyun.com/products/53398003/cmjj016263.html?spm=5176.10731542.0.0.b6f1677fKwFqek" target="_blank" rel="noopener">镜像页面</a>购买 <img src="/2020/08/07/ECS-7天实践训练营-day0/3.png" alt="LearningGp" /></li>
</ul>
<p>前两种方式需要在后续弹出界面选择需要的镜像</p>
<h3 id="安装mediawiki">安装MediaWiki</h3>
<h4 id="安装远程终端控制和文件传输">安装远程终端控制和文件传输</h4>
<p>课程采用的是PuTTY+FileZiila的方案，这两款比较简洁，适用性高。但是由于个人习惯还是采用了Xshell以及配套的Xftp。</p>
<h4 id="下载mediawiki">下载MediaWiki</h4>
<p><a href="https://releases.wikimedia.org/mediawiki/1.29/mediawiki-1.29.1.tar.gz" target="_blank" rel="noopener">下载MediaWiki并解压缩</a></p>
<h4 id="上传程序文件">上传程序文件</h4>
<ol type="1">
<li>进入 /data/wwwroot/default/ 目录，创建一个old文件夹，将目录上的原始文件全部搬到old内</li>
<li>将解压缩后的MediaWiki程序文件上传至 /data/wwwroot/default/ 目录 <img src="/2020/08/07/ECS-7天实践训练营-day0/e.png" alt="LearningGp" /></li>
<li>使用 chown 命令为目录赋予权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R www &#x2F;data&#x2F;wwwroot&#x2F;default</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="安装mediawiki-1">安装MediaWiki</h4>
<ol type="1">
<li>访问 http://公网IP，点击 【set up the wiki】</li>
<li>根据提示以及自身情况设置，其中有一些注意点</li>
</ol>
<ul>
<li>数据库选择轻量的SQLite<img src="/2020/08/07/ECS-7天实践训练营-day0/6.png" alt="LearningGp" /></li>
<li>刚开始可以跳过高级设置 <img src="/2020/08/07/ECS-7天实践训练营-day0/i.png" alt="LearningGp" /></li>
</ul>
<ol start="3" type="1">
<li>设置完成会生成配置文件LocalSettings.php并提示下载，下载后放入云服务器如图目录下 <img src="/2020/08/07/ECS-7天实践训练营-day0/ime.png" alt="LearningGp" /></li>
<li>重新访问http://公网IP，即可访问首页 <img src="/2020/08/07/ECS-7天实践训练营-day0/index.png" alt="LearningGp" /></li>
</ol>
<h3 id="使用mediawiki">使用MediaWiki</h3>
<h4 id="参数设置">参数设置</h4>
<p>在首页右上角使用管理员账号登录后，点击参数设置即可根据需要更改参数 <img src="/2020/08/07/ECS-7天实践训练营-day0/param.png" alt="LearningGp" /></p>
<h4 id="页面操作">页面操作</h4>
<p>大部分页面操作如编辑、保护、删除等均在页面上点击编辑或是更多即可实现。需要注意的是增加页面的操作。需要将url中的title参数改成词条名，例如http://120.26.163.147/index.php?title=LearningGp 然后点击创建本页面，输入信息后保存即可。 <img src="/2020/08/07/ECS-7天实践训练营-day0/new.png" alt="LearningGp" /></p>
<figure>
<img src="/2020/08/07/ECS-7天实践训练营-day0/name.png" alt="" /><figcaption>LearningGp</figcaption>
</figure>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>MediaWiki</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day03</title>
    <url>/2020/08/08/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day03/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day03">ECS 7天实践训练营@day03</h1>
<h2 id="有的没的">有的没的</h2>
<p>今天的课程总体和昨天的差不大多，不过由于个人暂时没有这方面的需求，所以也只是先做到了安装部署的步骤。前两天的笔记由于GitHub域名解析问题临时放到了csdn，所以今天将博客同时部署到GitHub以及coding，配置了域名的解析，国内的访问会解析到coding的page。个人测试没有啥问题，希望真的没有啥问题。（后续：又出现了问题，coding实在太慢了，现在部署到了云服务器上）开通云服务器、安装运行环境以及上传文件的的操作与昨天的相同，可以点击<a href="https://arvinhe.club/2020/08/07/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day02/#more" target="_blank" rel="noopener">链接</a>查看。</p>
<h2 id="基于云服务器构建微信公众号管理系统">基于云服务器构建微信公众号管理系统</h2>
<h3 id="开通云服务器">开通云服务器</h3>
<p>同样采用阿里云的ECS并在安全组中开放http80端口，https443端口，ssh22端口。</p>
<h3 id="安装运行环境">安装运行环境</h3>
<p>采用LAMP环境（Ubuntu 18.04 Apache PHP7.1）</p>
<h3 id="安装微擎">安装微擎</h3>
<h4 id="前置准备">前置准备</h4>
<p>微擎的install.php做了处理，所以要先去<a href="https://www.w7.cc/" target="_blank" rel="noopener">微擎官网</a>注册账号，然后再<a href="https://cdn.w7.cc/download/WeEngine-Laster-Online.zip" target="_blank" rel="noopener">下载</a>相关文件，并且解压上传到 <img src="/2020/08/08/ECS-7天实践训练营-day0/e.png" alt="LearningGp" /> 然后为目录赋予权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R www &#x2F;data&#x2F;wwwroot&#x2F;default</span><br></pre></td></tr></table></figure></p>
<h4 id="创建数据库">创建数据库</h4>
<ol type="1">
<li><p>查询数据库初始密码 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep dbrootpwd &#x2F;root&#x2F;oneinstack&#x2F;options.conf</span><br></pre></td></tr></table></figure> <img src="/2020/08/08/ECS-7天实践训练营-day0/mima.png" alt="LearningGp" /></p></li>
<li><p>浏览器打开http://ecs公网IP/old/phpmyadmin （这里我碰到一个小坑，会显示404，后来发现只要将old中phpMyaAdmin文件夹名称改为全小写字母即可）</p></li>
<li><p>输入 root 账户和密码，点击【执行】进行登录</p></li>
<li><p>在左侧列表点击【new】新建数据库，名称随意</p></li>
</ol>
<h4 id="安装微擎-1">安装微擎</h4>
<ol type="1">
<li><p>浏览器打开http://你的域名/install.php 登陆后进行安装（如果提示拒绝访问，没有权限之类可以再为目录赋予一下权限）</p></li>
<li><p>填写相关信息  - 数据库主机：localhost  - 数据库用户：root  - 数据库密码：之前查询出的密码  - 数据库名称：之前创建的数据库名称  - 表前缀：默认（ims_）</p></li>
</ol>
<h4 id="登录微擎">登录微擎</h4>
<p>访问自己的域名进入登录界面 <img src="/2020/08/08/ECS-7天实践训练营-day0/login.png" alt="LearningGp" /></p>
<p>登录后在左侧平台管理中可以添加平台 <img src="/2020/08/08/ECS-7天实践训练营-day0/pingtai.png" alt="LearningGp" /> 任选一个方式，相关信息可以在自己的公众号平台找到。因为个人暂时没这个需求就不深入了解啦。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>微擎</tag>
      </tags>
  </entry>
  <entry>
    <title>gitalk Error: Validation Failed</title>
    <url>/2020/05/30/gitalk-Error-Validation-Failed/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这个问题出现在这个博客基本搭建完成后，我发布第三篇文章时，解决的历程不算太困难，但是为了养成记录问题解决过程的习惯（这次就因为没养成习惯错过了截图），还是决定写下来，如果能帮到人就更好了。</p>
<h2 id="问题详情">问题详情</h2>
<p>问题环境：hexo+GitHub+next主题+gitalk<br />
问题描述：页面评论处出现Error: Validation Failed提示</p>
<h2 id="问题分析">问题分析</h2>
<p>在查阅了互联网之后，最后在gitalk的GitHub的<a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">issues</a>中得知主要原因在于gitalk将当前网址作为id属性，并在公开仓库创建相应label的issues实现存储评论，而GitHub限制label长度50从而使得部分文章导致无法创建。</p>
<h2 id="解决方案">解决方案</h2>
<p>比较方便的解决方案主要有以下两种</p>
<h3 id="方案一">方案一</h3>
<h4 id="方案描述">方案描述</h4>
<p>由于编码问题会在网址链接中出现16进制，使其超过长度限制导致无法创建，因此可以调用decodeURI函数，重新编码后用作id属性从而达到缩短的目的。不过该方案存在隐患，即当你的文章链接编码后仍超过限制就会失效，所以我最后没有采用这种方案。</p>
<h4 id="方案实施">方案实施</h4>
<p>找到主题文件路径下的gitalk.swig，我的具体路径为：hexo_third-party，将找到对应代码，将id部分进行如下修改 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">      clientID: &#39;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&#39;,</span><br><span class="line">      clientSecret: &#39;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&#39;,</span><br><span class="line">      repo: &#39;&#123;&#123; theme.gitalk.repo &#125;&#125;&#39;,</span><br><span class="line">      owner: &#39;&#123;&#123; theme.gitalk.githubID &#125;&#125;&#39;,</span><br><span class="line">      admin: [&#39;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&#39;],</span><br><span class="line">      id: location.pathname,</span><br><span class="line">      id: md5(location.pathname),</span><br><span class="line">      distractionFreeMode: &#39;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&#39;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure> <a href="https://blog.csdn.net/qing_gee/article/details/100134998" target="_blank" rel="noopener">方案来源</a></p>
<h3 id="方案二">方案二</h3>
<h4 id="方案描述-1">方案描述</h4>
<p>同方案一，主要目的仍是控制id属性的长度，所以可以采用将location.pathname进行md5加密得到等长字符串作为id，这样就可以无视原本长度将id长度控制在50以内，从而解决问题，本博客最后采用了这个方案。</p>
<h4 id="方案实施-1">方案实施</h4>
<h5 id="添加md5实现">添加md5实现</h5>
<p>这里采用<a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">blueimp/JavaScript-MD5</a>的代码，在该项目中找到js/md5.min.js。下载后放到主题目录下，我的具体路径为：hexo。 ##### 修改gitalk.swig 找到主题文件路径下的gitalk.swig，我的具体路径为：hexo_third-party。在该文件中加入md5.min.js引用，并对id部分进行修改，将location.pathname进行md5加密后作为id。修改后文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;gitalk&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;gitalk&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;md5.min.js&quot;&gt;&lt;&#x2F;script&gt; </span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">      clientID: &#39;&#123;&#123; theme.gitalk.clientID &#125;&#125;&#39;,</span><br><span class="line">      clientSecret: &#39;&#123;&#123; theme.gitalk.clientSecret &#125;&#125;&#39;,</span><br><span class="line">      repo: &#39;&#123;&#123; theme.gitalk.repo &#125;&#125;&#39;,</span><br><span class="line">      owner: &#39;&#123;&#123; theme.gitalk.owner &#125;&#125;&#39;,</span><br><span class="line">      admin: [&#39;&#123;&#123; theme.gitalk.admin &#125;&#125;&#39;],</span><br><span class="line">      id: md5(location.pathname),</span><br><span class="line">      distractionFreeMode: &#39;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/death05/article/details/83618887" target="_blank" rel="noopener">方案来源</a></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>同计算机网络这篇文章是个人本科期间学习操作系统时用幕布做的笔记，在准备考研时做了些修改，部分略微有些过于具体。同时由于具体格式还没处理的很完美，就先分章节以幕布的链接形式给出,进入链接可以自行展开需要的点。   <em>p.s.参考书目：《操作系统教程》（第5版），费翔林、骆斌编著，高等教育出版社。</em></p>
<h2 id="干货">干货</h2>
<h3 id="知识点思维导图">知识点思维导图</h3>
<p><img src="/2020/05/27/操作系/os.png" /></p>
<h3 id="分章节知识大纲">分章节知识大纲</h3>
<ul>
<li><a href="https://mubu.com/doc/teE-ZHEdWR" target="_blank" rel="noopener">概述</a> 密码: roh7</li>
<li><a href="https://mubu.com/doc/ge2OaWXQaR" target="_blank" rel="noopener">进程、线程与作业</a> 密码: 6mqv</li>
<li><a href="https://mubu.com/doc/6hUG5bKWpqR" target="_blank" rel="noopener">中断与处理机调度</a> 密码: zip9</li>
<li><a href="https://mubu.com/doc/H_hoig98WR" target="_blank" rel="noopener">互斥、同步与通讯</a> 密码: 1rqj</li>
<li><a href="https://mubu.com/doc/6htQwgEnPWR" target="_blank" rel="noopener">死锁与饥饿</a> 密码: yz0v</li>
<li><a href="https://mubu.com/doc/3yI3gEg4MaR" target="_blank" rel="noopener">存储管理</a> 密码: ypqu</li>
<li><a href="https://mubu.com/doc/mp_EIxOqqR" target="_blank" rel="noopener">文件系统</a> 密码: agdg</li>
<li><a href="https://mubu.com/doc/1HUdG8lPcqR" target="_blank" rel="noopener">设备与IO管理</a> 密码: 2701</li>
</ul>
<h3 id="合集">合集</h3>
<ul>
<li><a href="https://mubu.com/doc/5k6-7tXTKWR" target="_blank" rel="noopener">合集</a> 密码: n8io</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2020/06/20/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="单调栈">单调栈</h1>
<h2 id="定义">定义</h2>
<p>单调栈就是满足单调性的栈结构。</p>
<h2 id="性质">性质</h2>
<ul>
<li>单调栈里的元素具有单调性；</li>
<li>每个元素在入栈前，将栈顶破坏栈单调性的元素都出栈；</li>
<li>使用单调栈可以找到入栈时元素向左遍历到的第一个比他小（大）的元素；出栈时元素向右遍历第一个比他小（大）的元素。（做题大多依靠这条性质）</li>
</ul>
<h1 id="例题">例题</h1>
<h2 id="每日温度">739 每日温度</h2>
<h3 id="题目描述">题目描述</h3>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<p><a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="解释">解释</h3>
<p>这道题思路比较明显，找每一个数右边第一个比他大的数。所以可以使用单调栈实现。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; I=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">if</span> (T.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        I.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tempT=T[i];</span><br><span class="line">            <span class="keyword">while</span> (!I.isEmpty() &amp;&amp; T[I.getLast()]&lt;tempT)&#123;</span><br><span class="line">                <span class="keyword">int</span> pI=I.removeLast();</span><br><span class="line">                result[pI]=i-pI;</span><br><span class="line">            &#125;</span><br><span class="line">            I.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!I.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i:I</span><br><span class="line">                 ) &#123;</span><br><span class="line">                result[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柱状图中最大的矩形">84 柱状图中最大的矩形</h2>
<h3 id="题目描述-1">题目描述</h3>
<p>给定n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出来的矩形的最大面积。  </p>
<p><img src="/2020/06/20/单调/1.png" alt="LearningGp" /> 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p><img src="/2020/06/20/单调/2.png" alt="overwrote existing file" /> 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10个单位。 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="解释-1">解释</h3>
<p>每个能勾勒出的矩形其实可以理解成为其中最短的一个柱体向左右拓展。所以暴力枚举方法为:</p>
<ul>
<li>枚举某一柱子</li>
<li>向左右拓展直到遇到高度小于其的柱子停止</li>
<li>计算面积</li>
</ul>
<p>但是我们可以发现这边其实要找的就是某一柱子的左边以及右边第一个比它矮的柱子，这个需求非常符合单调栈的第三条性质。所以这题可以使用单调栈来优化解决。将每个柱体依次入栈，若当前的柱体高度大于等于栈顶柱体的高度，就直接将当前柱体入栈，否则当前栈顶的柱体就找到了右边的第一个小于自身的柱体（右边界），而对栈中柱体来说，栈中的下一个柱体就是其左边第一个小于自身的柱体（左边界）那么就可以将栈顶柱体出栈并计算面积。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(right, n);</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[stack.peek()] = i;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (stack.isEmpty() ? -<span class="number">1</span> : stack.peek());</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接雨水">42 接雨水</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>给定n个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。  </p>
<p><img src="/2020/06/20/单调/3.png" alt="LearningGp" /> <strong>示例:</strong> <strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1] <strong>输出:</strong> 6 <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="解释-2">解释</h3>
<p>这题依旧可以看出是寻找边界的题目。栈顶元素是左边界，当前柱体是右边界，当前高度是两者高度中的较小者减去计算过的高度。<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/" target="_blank" rel="noopener">详解来自Sweetiee</a></p>
<h3 id="代码-2">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每个柱子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算当前柱子左侧的柱子中的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                leftMax = Math.max(leftMax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算当前柱子右侧的柱子中的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; height.length; j++) &#123;</span><br><span class="line">                rightMax = Math.max(rightMax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 结果中累加当前柱子顶部可以储水的高度，</span></span><br><span class="line">            <span class="comment">// 即 当前柱子左右两边最大高度的较小者 - 当前柱子的高度。</span></span><br><span class="line">            res += Math.min(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于deque">关于Deque</h1>
<p>在这篇文章给出的代码中有些使用了Deque代替stack，或是对Deque进行一次封装代替stack。原先的stack不符合OOP设计原则。虽然stack仍未被弃用，且在算法题中影响不大，但是确实Deque作为双端队列更加方便，但如果出于封装性的考虑，可以对Deque再做一次封装，限制非栈操作。<a href="https://mp.weixin.qq.com/s/Ba8jrULf8NJbENK6WGrVWg" target="_blank" rel="noopener">详细解释</a></p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>起点</title>
    <url>/2020/05/25/%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<h3 id="有的没的">有的没的</h3>
<p>搭建个人博客的念头也是早就有了，就是一直没有这个时间或是契机吧，各种个人笔记和刷题笔记都散落在不同的应用里，感觉有些杂乱而且浪费。所以趁这段时间将这个博客搭了起来，之前的各种笔记都会慢慢搬到这里，即便没人看，也权当是自己的仓库，记录自己的技术成长吧。暂时用LearningGp作为博客名，这个名字最早是游戏角色的名字LearningGroup但是因为那个游戏有长度限制，就变成了现在这样。游戏倒是没在玩了，名字倒是留下了。希望能把这个小地方一直做下去吧。</p>
<h3 id="规划">规划</h3>
<p>目前已经想好分类如下</p>
<ul>
<li>刷题记录——主要记录算法题题解</li>
<li>知识图谱——主要记录学过科目的知识图谱</li>
<li>踩坑记录——各种踩过的解决的没解决的坑</li>
<li>随笔——一些有的没的</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这篇文章是个人本科期间学习计算机网络时用幕布做的笔记，在准备考研时做了些修改，部分略微有些过于具体。同时由于具体格式还没处理的很完美，就先分章节以幕布的链接形式给出,进入链接可以自行展开需要的点。<br />
<em>p.s.参考书目：《计算机网络》（第7版），谢希仁著，电子工业出版社。</em></p>
<h2 id="干货">干货</h2>
<h3 id="知识点思维导图">知识点思维导图</h3>
<p><img src="/2020/05/26/计算机网/network.png" /></p>
<h3 id="分章节知识大纲">分章节知识大纲</h3>
<ul>
<li><a href="https://mubu.com/doc/gqn4PLygh0" target="_blank" rel="noopener">概述</a> 密码: 4igo</li>
<li><a href="https://mubu.com/doc/6o91f8PaWVR" target="_blank" rel="noopener">应用层</a> 密码: 2m1h</li>
<li><a href="https://mubu.com/doc/6-KYTSqvOVR" target="_blank" rel="noopener">运输层</a> 密码: 9uot</li>
<li><a href="https://mubu.com/doc/1sETTUIvH9R" target="_blank" rel="noopener">网络层</a> 密码: 4mk7</li>
<li><a href="https://mubu.com/doc/2nnoStqrP9R" target="_blank" rel="noopener">数据链路层</a> 密码: 0n0g</li>
<li><a href="https://mubu.com/doc/17eAGAnsMpR" target="_blank" rel="noopener">物理层</a> 密码: cjd3</li>
<li><a href="https://mubu.com/doc/5gRz5-bMwFR" target="_blank" rel="noopener">无线网络</a> 密码: zjwe</li>
<li><a href="https://mubu.com/doc/3qkfIGReLFR" target="_blank" rel="noopener">杂</a> 密码: uota</li>
</ul>
<h3 id="合集">合集</h3>
<ul>
<li><a href="https://mubu.com/doc/5ShTlP-750" target="_blank" rel="noopener">合集</a> 密码: vkai</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读的逻辑</title>
    <url>/2020/05/27/%E9%98%85%E8%AF%BB%E7%9A%84%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这篇笔记是准备考研时在学习唐迟老师英语阅读课程时记下的，感觉上老师的这种基于逻辑的做题思路对于考试或是读英文论文都有较大帮助，不过笔记主要服务于考试。具体的思想可以去唐老师课上体会。</p>
<h2 id="大原则">大原则</h2>
<h3 id="时间对比原则">时间对比原则</h3>
<ul>
<li>过去不重要，现在才重要，本质是转折（特别注意末端转折）</li>
<li>Used to be（过去常常，潜台词现在已经不这样）</li>
<li>traditional（时间对比，表示过去）</li>
<li>No longer；while；today</li>
<li>Now 后面要么是全文中心，要么是题目的答案</li>
</ul>
<h3 id="把握作者态度">把握作者态度</h3>
<ul>
<li>逻辑</li>
<li>（形容词，副词）正向，负向态度</li>
<li>同义替换</li>
<li>中心、主旨（串线；中心句；中心词）</li>
</ul>
<h2 id="题型">题型</h2>
<h3 id="细节题">细节题</h3>
<ul>
<li>定位好的句子是解题的重要依据</li>
</ul>
<h3 id="中心思想主旨题">中心思想/主旨题</h3>
<ul>
<li>标志
<ul>
<li>Mainly about/discuss</li>
<li>The best title/ a appropriate title</li>
<li>The purpose</li>
</ul></li>
<li>方法
<ul>
<li>串线（最普适）：将各段首末句串联成一个整体，注意转折处；（80%看首句）</li>
<li>中心词（最直观）：文中反复高频出现的词（包括同义替换）；</li>
<li>中心句（最需要练习）：
<ul>
<li>①问题开头的提问的回答；--好奇害死猫</li>
<li>②独句段（独句段不一定短）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="作者态度题">作者态度题</h3>
<ul>
<li>标志
<ul>
<li>attitude deem consider tone</li>
</ul></li>
<li>方法
<ul>
<li>正面：positive optimistic approval suppportive</li>
<li>负面：negative pessimistic disapproval critical doubtful suspicious skeptical quentionable</li>
<li>中性：neutral objective impartial disinterested</li>
<li>注：critical adj.重要的；批评的be critical of</li>
</ul></li>
<li>小墓碑选项
<ul>
<li>漠不关心的：uninterested unconcerned indifferent</li>
<li>困惑的：confused puzzled</li>
<li>偏见的：biased prejudice contemptuous subjective</li>
<li>基本不选择</li>
</ul></li>
<li>当作者的态度没有明确提出时
<ul>
<li>文章的框架（串线——中心/态度）</li>
<li>adj./adv. （感情色彩强烈的，尤其是修饰主题词的）</li>
<li>转折处</li>
<li>情态动词之后（should/must/could/may/might/need……）</li>
</ul></li>
</ul>
<h3 id="推测词意">推测词意</h3>
<ul>
<li>方法
<ul>
<li>上下文（本句内）逻辑关系，提炼出不断重复的内容（被不断重复的同义词、近义词、but之后的反义词）</li>
<li>排除表面意思</li>
<li>全文中心主旨</li>
</ul></li>
</ul>
<h3 id="例证题">例证题</h3>
<ul>
<li>标志
<ul>
<li>example case illustrate demonstrate to show to_______</li>
</ul></li>
<li>例子本身不重要，重要的是例子所支持的观点
<ul>
<li>观点一般在例子前，有时也在例子后。（找到正确的）</li>
<li>干扰选项：就事论事 ——讲例子本身（排除错误的）</li>
</ul></li>
<li>观点出现位置
<ul>
<li>转折</li>
<li>感情色彩强的词（例子是客观的）</li>
<li>情态动词（shuld could ）</li>
<li>I/we</li>
</ul></li>
</ul>
<h3 id="推理题">推理题</h3>
<ul>
<li>标志
<ul>
<li>infer imply suggest learn from</li>
</ul></li>
<li>方法
<ul>
<li>细节 + 主旨 + 逻辑</li>
<li>排除细节重复错误的选项</li>
<li>干扰选项特征：貌似相关，无中生有</li>
</ul></li>
</ul>
<h2 id="小技巧">小技巧</h2>
<ul>
<li>串题干
<ul>
<li>只看题干，不看选项，把握大体内容</li>
</ul></li>
<li>注意同义替换</li>
<li>逻辑提示词
<ul>
<li>时间，转折，情感色彩形容词、副词</li>
</ul></li>
<li>While
<ul>
<li>80%考察对比，翻译为尽管</li>
</ul></li>
<li>But
<ul>
<li>多数用于表递进</li>
</ul></li>
<li>代词指代
<ul>
<li>帮助理解概念性含义</li>
<li>出现在一个新的名词前时，那么这个名词一定是前面某一个词的同义替换</li>
<li>优先指代上文中心（再考虑就近原则）</li>
</ul></li>
<li>反复强调的是重点，重点是考点</li>
<li>选项中需要注意的用词
<ul>
<li>绝对化用词（文中做标记）</li>
<li>比较级</li>
</ul></li>
<li>干扰选项一定是围绕正确选项来设计的，做题时可以去除意思相同词语，只关注区别</li>
<li>转折处常做正确答案命题点</li>
<li>三要素
<ul>
<li>逻辑</li>
<li>情感</li>
<li>同义替换</li>
</ul></li>
<li>注意“？”</li>
<li>单独的数字是没有意义的，重要的是对比的数字</li>
<li>作者态度题题干中的词一定是中心话题的组成部分</li>
<li>细节服务主旨</li>
<li>instead单独使用时，上下文表示相同逻辑</li>
<li>Instead of 前后部分相反</li>
<li>出题顺序与行文顺序一致</li>
<li>A与B互为相反，很有可能有一个是正确答案</li>
<li>少数派往往是重要的</li>
<li>当题干明确告诉考虑两段，注意考察的是交集</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程</title>
    <url>/2020/05/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这篇文章是个人研究生初试学习软件工程时用幕布做的笔记，同时也加入了一些搜集于其他书本以及网络的内容。《软件工程与计算：软件开发的技术基础》这本书个人感觉内容过于丰富充实，再学习时很有压力且容易流于表面。需要补充许多另外的知识与思想，有条件的话推荐搭配南大本科相关课程视频，收益良多。同时由于具体格式还没处理的很完美，就先以幕布的链接形式给出,进入链接可以自行展开需要的点。   <em>p.s.主要参考书目：《软件工程与计算：软件开发的技术基础》，骆斌主编、丁二玉、刘钦编著，机械工业出版社。</em></p>
<h2 id="干货">干货</h2>
<h3 id="知识点思维导图">知识点思维导图</h3>
<p><img src="/2020/05/30/软件工/software.png" /></p>
<h3 id="合集">合集</h3>
<ul>
<li><a href="https://mubu.com/doc/3NhfNkdYONR" target="_blank" rel="noopener">合集</a> 密码: ko0y</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题64 求1+2+...+n</title>
    <url>/2020/06/02/%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%B1%821-2-n/</url>
    <content><![CDATA[<h1 id="面试题64-求12...n">面试题64 求1+2+...+n</h1>
<p>难度：中等</p>
<p>平台：leetcode</p>
<h2 id="description">Description</h2>
<p>求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例 1：</p>
<p>输入: n = 3 输出: 6 示例 2：</p>
<p>输入: n = 9 输出: 45</p>
<p>限制：</p>
<p>1 &lt;= n &lt;= 10000</p>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof</a></p>
<h2 id="mysolution">MySolution</h2>
<p>这道题算是一股清流，所以记录下来。刚看到题有点懵，先想到的是求和公式<strong>n*(n+1)/2</strong>但是不能用乘除法，除2操作可以用&gt;&gt;=1代替，但是<strong>n*(n+1)</strong>一下子没有想到代替的办法（后来在题解中找到，本文作为其他解法给出）在公式法无法进行时想到了递归法，因为递归出口可以用&amp;&amp;的一个性质实现——如果左边为假便不判断右边表达式（后来在题解里发现这个称为逻辑运算符的短路性质,||也有类似性质）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> f;</span><br><span class="line">        f = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="othersolutions">OtherSolutions</h2>
<p>接之前讲的公式法，在实现<strong>n*(n+1)</strong>时用到了<a href="http://mathforum.org/dr.math/faq/faq.peasant.html" target="_blank" rel="noopener">俄罗斯农民乘法</a>，原理简单来说就是若<strong>A*B</strong>，我们将<strong>A*2</strong>作为新A的同时<strong>B/2</strong>作为新B，如果原B为偶数则由于乘法交换律结果不变，如果原B为奇数由于自动取下界我们则丢失了一个原A，需要在最后结果补上一个原A。如此反复到B为1，此时补上所有中途丢失的数即为结果。对应到2进制，我们可以用左移一位和右移一位代替<strong>*2</strong>与<strong>/2</strong>操作，B的二进制展开是否为1作为是否需补的标志，同时由于不能使用循环，结合数据范围，我们需要手动展开14位最终实现求和公式<strong>n*(n+1)/2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/" target="_blank" rel="noopener">LeetCode-Solution</a></p>
<h2 id="有的没的">有的没的</h2>
<p>通过这道题，发现自己对于位运算的知识不熟悉，解题时不能及时想到。可见还有许多这样平时不常常接触但是有用的知识点需要我去熟悉。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day05</title>
    <url>/2020/08/10/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day05/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day05">ECS 7天实践训练营@day05</h1>
<h2 id="有的没的">有的没的</h2>
<p>昨天的课程是在线编程比赛，成绩不太满意感觉退步蛮多，最近也确实没有好好刷算法，还是得多花些时间在算法上。今天的课程是搭建Java Web开发环境。因为之前做过Java Web的项目，所以都还算熟悉。课程讲的很详细，也是跟着做就ok。<a href="https://developer.aliyun.com/adc/scenario/bbad6f5e0cba4c0ba5c904f6cf06a8d0" target="_blank" rel="noopener">体验链接</a></p>
<h2 id="搭建java-web开发环境">搭建Java Web开发环境</h2>
<p>Java Web开发环境最基础的就是JDK+MySQL+TomCat，基本流程就是按顺序安装即可。</p>
<h3 id="创建资源连接云服务器">创建资源&amp;连接云服务器</h3>
<p>这两个步骤与之前没有差别，就不再赘述。</p>
<h3 id="安装jdk">安装JDK</h3>
<ol type="1">
<li><p>执行以下命令，查看yum源中JDK版本 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list java*</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，使用yum安装JDK1.8 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，查看是否安装成功 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure> <img src="/2020/08/10/ECS-7天实践训练营-day0/java.png" alt="LearningGp" /></p></li>
</ol>
<h3 id="安装mysql数据库">安装MySQL数据库</h3>
<ol type="1">
<li><p>依次执行下方命令，下载并安装MySQL官方的Yum Repository <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，启动 MySQL 数据库 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，查看MySQL初始密码(最后的即为密码) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure> <img src="/2020/08/10/ECS-7天实践训练营-day0/mysql.png" alt="LearningGp" /></p></li>
<li><p>执行以下命令,输入前面获取的密码，登录数据库（出现mysql&gt;即为登录成功） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，修改MySQL默认密码(也可以不输入第一行，第二行将密码改为符合原密码安全策略的复杂密码) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy&#x3D;0;  #修改密码安全策略为低（只校验密码长度，至少8位）。</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，授予root用户远程管理权限(熟悉mysql的可以为项目建立对应用户，授予相应用户相应的远程权限) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;12345678&#39;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>输入exit退出数据库</p></li>
</ol>
<h3 id="安装tomcat">安装Tomcat</h3>
<ol type="1">
<li><p>执行以下命令，下载Tomcat压缩包 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-8&#x2F;v8.5.57&#x2F;bin&#x2F;apache-tomcat-8.5.57.tar.gz</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，解压刚刚下载Tomcat包 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.57.tar.gz</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，修改Tomcat名字(方便操作) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv apache-tomcat-8.5.57 &#x2F;usr&#x2F;local&#x2F;Tomcat8.5</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，为Tomcat授权 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;Tomcat8.5&#x2F;bin&#x2F;*.sh</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，修改Tomcat默认端口号为80（主要是为了能够输入地址直接访问而不用输入端口号） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &#39;s&#x2F;Connector port&#x3D;&quot;8080&quot;&#x2F;Connector port&#x3D;&quot;80&quot;&#x2F;&#39; &#x2F;usr&#x2F;local&#x2F;Tomcat8.5&#x2F;conf&#x2F;server.xml</span><br></pre></td></tr></table></figure></p></li>
<li><p>启动Tomcat(为了方便也可以将其添加为服务) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Tomcat8.5&#x2F;bin&#x2F;.&#x2F;startup.sh</span><br></pre></td></tr></table></figure> ### 访问Tomcat 打开浏览器，在地址栏中输入ECS公网地址，如显示下图界面，则搭建完成 <img src="/2020/08/10/ECS-7天实践训练营-day0/tomcat.png" alt="LearningGp" /></p></li>
</ol>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day06</title>
    <url>/2020/08/11/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day06/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day06">ECS 7天实践训练营@day06</h1>
<h2 id="有的没的">有的没的</h2>
<p>今天的课程是搭建离线下载服务器，主要用于帮助我们离线下载一些网络资源，方便我们直接从服务器取用，在服务器网络带宽够大的情况下，能帮助我们下载比较大的文件。流程依旧讲解的很清楚，跟着做基本没有问题。今天是训练营最后一天了，总体下来收获还是挺多的，之后的几天会好好考虑怎么更好的利用云服务器来方便生活学习。</p>
<h2 id="打造离线下载服务器">打造离线下载服务器</h2>
<h3 id="创建资源连接云服务器">创建资源&amp;连接云服务器</h3>
<p>这两个步骤与之前没有差别，就不再赘述。(安全组处需要开启6080端口)</p>
<h3 id="下载安装ccaa方案包">下载安装CCAA方案包</h3>
<ol type="1">
<li><p>输入命令下载（完成后自动开始安装） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#国内服务器</span><br><span class="line">bash &lt;(curl -Lsk</span><br><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helloxz&#x2F;ccaa&#x2F;master&#x2F;ccaa.sh) cdn</span><br><span class="line">#海外服务器</span><br><span class="line">bash &lt;(curl -Lsk</span><br><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helloxz&#x2F;ccaa&#x2F;master&#x2F;ccaa.sh)</span><br></pre></td></tr></table></figure></p></li>
<li><p>输入1安装CCAA <img src="/2020/08/11/ECS-7天实践训练营-day0/2.png" alt="LearningGp" /></p></li>
<li><p>设置下载路径，可以直接回车 <img src="/2020/08/11/ECS-7天实践训练营-day0/3.png" alt="LearningGp" /></p></li>
<li><p>输⼊ Aria2 的 RPC 通信密钥，输⼊不含特殊字符的内容即可 <img src="/2020/08/11/ECS-7天实践训练营-day0/4.png" alt="LearningGp" /></p></li>
<li><p>安装成功 <img src="/2020/08/11/ECS-7天实践训练营-day0/5.png" alt="LearningGp" /></p></li>
<li><p>设置 浏览器打开上一步显示的url，进入设置，填写密钥后点击重新载入即可 <img src="/2020/08/11/ECS-7天实践训练营-day0/6e.png" alt="overwrote existing file" /></p></li>
</ol>
<h3 id="使用离线下载服务器">使用离线下载服务器</h3>
<h4 id="常用命令">常用命令</h4>
<ul>
<li>ccaa:进⼊CCAA操作界⾯</li>
<li>ccaa status:查看CCAA运⾏状态</li>
<li>ccaa stop:停⽌CCAA</li>
<li>ccaa start:启动CCAA</li>
<li>ccaa restart:重启CCAA</li>
<li>ccaa -v:查看CCAA版本（2.0开始⽀持）</li>
</ul>
<h4 id="离线下载">离线下载</h4>
<p>界面其实比较容易理解，点击新建后输入下载链接，分行可输入多个链接后点击立即下载即可，也可以上传种子文件。</p>
<h4 id="下载至本地">下载至本地</h4>
<p>在文件管理中选中所需要的文件，点击下载即可（推荐按量付费的云服务器，可以保证速度）</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>CCAA</tag>
      </tags>
  </entry>
  <entry>
    <title>网络爬虫笔记</title>
    <url>/2020/10/21/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="爬虫笔记">爬虫笔记</h1>
<h2 id="有的没的">有的没的</h2>
<p>这个笔记是一个目录性质的笔记，主要是方便自己日后回忆，如果有有缘的大兄弟也学习了这套课程，欢迎交流。这套课程感觉还是挺实用的，在学习过程中也试着解决了一些正好遇到的需求。课程在B站上有（路飞学城）。<br />
自己学习过程中写的相关代码都push到了自己的<a href="https://github.com/LearningGp/WebCrawler" target="_blank" rel="noopener">GitHub</a>上，可以自由查阅。之后可能也会就一些部分写详细的学习笔记。</p>
<h2 id="http">http</h2>
<h3 id="常用请求头信息">常用请求头信息</h3>
<ul>
<li>User-Agent：请求载体的身份标识</li>
<li>Connection：请求完毕后，是否保持连接</li>
</ul>
<h3 id="常用响应头信息">常用响应头信息</h3>
<ul>
<li>Content-Type：服务器响应回客户端的数据类型</li>
</ul>
<h2 id="https">https</h2>
<p>安全的超文本传输协议</p>
<h3 id="加密方式">加密方式</h3>
<ul>
<li>对称密钥加密</li>
<li>非对称密钥加密</li>
<li>证书密钥加密（https）</li>
</ul>
<h2 id="requests模块">requests模块</h2>
<p>python中原生的基于网络请求的模块，用于模拟浏览器发请求。</p>
<h3 id="流程">流程</h3>
<ul>
<li>指定url</li>
<li>发起请求</li>
<li>获取响应数据</li>
<li>持久化存储</li>
</ul>
<h3 id="实例">实例</h3>
<ul>
<li><p>例1 爬取百度首页</p></li>
<li><p>例2 爬取百度查询页面</p></li>
<li><p>例3 爬取百度翻译结果</p></li>
<li><p>例4 爬取豆瓣电影排名</p></li>
<li><p>练习 爬取KFC餐厅地址</p></li>
<li><p>例5 爬取药监局网站信息</p></li>
</ul>
<h2 id="聚焦爬虫">聚焦爬虫</h2>
<h3 id="流程-1">流程</h3>
<ul>
<li>指定url</li>
<li>发起请求</li>
<li>获取响应数据</li>
<li>数据解析</li>
<li>持久化存储</li>
</ul>
<h3 id="实现">实现</h3>
<h4 id="正则">正则</h4>
<p>利用正则表达式从爬取的数据中匹配出我们所需要的部分</p>
<h5 id="常用表达式">常用表达式</h5>
<figure>
<img src="/2020/10/21/网络爬虫笔/zhengze.png" alt="" /><figcaption>LearningGp</figcaption>
</figure>
<h5 id="实例-爬取糗事百科图片">实例 爬取糗事百科图片</h5>
<h4 id="bs4">bs4</h4>
<h5 id="步骤简介">步骤简介</h5>
<ol type="1">
<li>实例化BeautifulSoup对象</li>
<li>将页面源码数据加载到该对象中</li>
<li>通过BeautifulSoup对象的属性或方法定位标签以及数据提取</li>
</ol>
<h5 id="数据解析相关方法和属性">数据解析相关方法和属性</h5>
<ul>
<li>tagName：返回html中第一次出现的tagName标签</li>
<li>find():
<ul>
<li>find('tagName')：返回html中第一次出现的tagName标签</li>
<li>find('tagName',class_/id/attr='xxx' ):属性定位</li>
</ul></li>
<li>find_all()：同find，但是返回所有符合条件项（列表）</li>
<li>select()：
<ul>
<li>select('某种选择器（id，class，标签）')：返回列表</li>
<li>select('用&gt;以及空格连接的多个选择器组成层级选择器')：返回列表（&gt;表示一个层级，空格表示多个层级）</li>
</ul></li>
<li>获取标签之间的文本数据
<ul>
<li>text/string/get_text()
<ul>
<li>text/get_text()：获取所定位标签下所有文本</li>
<li>string：只获取所定位标签下直系文本</li>
</ul></li>
</ul></li>
<li>获取标签中的属性值
<ul>
<li>['标签名']</li>
</ul></li>
</ul>
<h5 id="实例-爬取三国演义所以章节标题和内容">实例 爬取三国演义所以章节标题和内容</h5>
<h4 id="xpath">xpath</h4>
<p>最常用且最便捷高效的解析方式，同时具有较好的通用性</p>
<h5 id="步骤简介-1">步骤简介</h5>
<ol type="1">
<li>实例化etree的对象
<ul>
<li>加载本地文档：etree.parse(filePath)</li>
<li>加载网络上获取的源码数据：etree.HTML('page_text')</li>
</ul></li>
<li>将页面源码数据加载到该对象中</li>
<li>调用rtree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获</li>
</ol>
<h4 id="xpath表达式">xpath表达式</h4>
<p>返回基本为列表，定位阶段列表内为对象（tips：谷歌浏览器F12下，Elemens窗口下选中需要的标签右键-&gt;copy-&gt;copy Xpath 可以复制对应Xpath，按需修改） - 标签定位：'/html/head/title'（层级定位） - /：表示一个层级 - //：表示多个层级，或表示从任意位置开始定位 - 属性定位：'//div<span class="citation" data-cites="class">[@class="song"]</span>' - 索引定位：'//div<span class="citation" data-cites="class">[@class="song"]</span>/p[3]'（该div下第三个p标签，从1开始） - 取文本：'/html/head/title/text()' - 取属性：'//div<span class="citation" data-cites="class">[@class="song"]</span>/img/<span class="citation" data-cites="src">@src</span>'</p>
<h4 id="实例-1">实例</h4>
<ul>
<li><p>实例1 爬取58同城二手房标题</p></li>
<li><p>实例2 爬取图片</p></li>
<li><p>实例3 爬取城市名称</p></li>
<li><p>练习1 爬取简历模板</p></li>
</ul>
<h2 id="验证码识别">验证码识别</h2>
<h3 id="简介">简介</h3>
<p>这边采用将验证码图片下载下来后调用第三方识别服务进行识别，本文采用超级鹰的服务，需要提前前往其网站注册账号并充值。</p>
<h3 id="实例-2">实例</h3>
<ul>
<li><p>实例1 超级鹰服务测试</p></li>
<li><p>实例2 古诗文网站验证码识别</p></li>
</ul>
<h2 id="代理爬虫">代理爬虫</h2>
<h3 id="简介-1">简介</h3>
<p>主要作用有</p>
<ol type="1">
<li>突破自身IP访问的限制</li>
<li>隐藏自身真实IP</li>
</ol>
<p>代理相关工具网站</p>
<ul>
<li>快代理</li>
<li>西祠代理</li>
<li>www.goubanjia.com</li>
</ul>
<h3 id="实现-1">实现</h3>
<h4 id="实例-代理爬虫查询ip">实例 代理爬虫查询IP</h4>
<h2 id="异步爬虫">异步爬虫</h2>
<h3 id="简介-2">简介</h3>
<p>单线程串行的方式爬取效率较低，需要我们通过一些方法实现异步爬虫。</p>
<h3 id="实现方式">实现方式</h3>
<ul>
<li>多线程，多进程（不推荐）
<ul>
<li>好处 ：为相关的阻塞操作开启线程或进程，阻塞操作就可以异步执行</li>
<li>弊端：无法无限制开启多线程或多进程</li>
</ul></li>
<li>线程池、进程池（适当使用）
<ul>
<li>好处：降低系统对进程或者线程创建和销毁的频率，降低系统开销</li>
<li>弊端：池中线程或进程的数量有上限</li>
</ul></li>
<li>单线程+异步协程（推荐）
<ul>
<li>使用asyncio以及aiohttp实现</li>
</ul></li>
</ul>
<h2 id="selenium模块">selenium模块</h2>
<h3 id="简介-3">简介</h3>
<p>是一个自动化测试工具,而爬虫中使用它主要是为了解决requests无法直接执行JavaScript代码的问题 selenium本质是通过驱动浏览器，完全模拟浏览器的操作，比如跳转、输入、点击、下拉等，来拿到网页渲染之后的结果，可支持多种浏览器</p>
<h3 id="实例-3">实例</h3>
<ul>
<li>例1 人人网模拟登录</li>
</ul>
<h2 id="scrapy框架">scrapy框架</h2>
<h3 id="简介-4">简介</h3>
<p>一个为了爬取网站数据，提取结构性数据而编写的应用框架。其内部已经被集成了各种功能（高性能异步下载，队列，分布式，解析，持久化等）。</p>
<h3 id="流程-2">流程</h3>
<ul>
<li>创建工程：
<ul>
<li>scrapy startproject ProName</li>
</ul></li>
<li>进入工程目录：
<ul>
<li>cd ProName</li>
</ul></li>
<li>创建爬虫文件：
<ul>
<li>scrapy genspider spiderName www.xxx.com</li>
</ul></li>
<li>编写相关操作代码</li>
<li>执行工程：
<ul>
<li>scrapy crawl spiderName</li>
</ul></li>
</ul>
<h3 id="功能">功能</h3>
<h4 id="基于管道的持久化存储">基于管道的持久化存储</h4>
<ul>
<li>修改item文件</li>
<li>修改pipelines文件</li>
<li>修改配置文件</li>
</ul>
<h4 id="便捷的全站爬取">便捷的全站爬取</h4>
<h4 id="支持分布式集群">支持分布式集群</h4>
<h3 id="实例-4">实例</h3>
<ul>
<li><p>例1 爬取糗百（持久化）</p></li>
<li><p>例2 爬取boss直聘（中间件）</p></li>
<li><p>例3 爬取图片</p></li>
<li><p>例4 爬取网易（手动全站）</p></li>
<li><p>例5 爬取阳光政务（自动全站）</p></li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java访问权限之Protected</title>
    <url>/2020/12/20/JavaProtected%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="java访问权限之protected">Java访问权限之Protected</h1>
<h2 id="有的没的">有的没的</h2>
<p>示例来自于<a href="https://www.notion.so/Java-_CSDN-ff61590bf13042aca5962bb20ca6d8e6" target="_blank" rel="noopener">Java 访问权限控制_CSDN</a>，然后个人感觉原文很详细但是解释的不太自洽，自行解释了一下。</p>
<h2 id="可见性规则">可见性规则</h2>
<ul>
<li>基类的protected成员是包内可见的，并且对子类可见；
<ul>
<li>（自己实现的类，仅包内以及子类可见）</li>
</ul></li>
<li>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。
<ul>
<li>（不同包时继承得到的方法只能由自己和自己的父类可见）</li>
<li>（不同包时继承得到的方法，自己只能看见自己的方法）</li>
</ul></li>
</ul>
<h2 id="示例分析">示例分析</h2>
<h3 id="示例一">示例一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例一</span></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">// 父类Father1中的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father1</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p11;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son11</span> <span class="keyword">extends</span> <span class="title">Father1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son1 son1 = <span class="keyword">new</span> Son1();</span><br><span class="line">        son1.f(); <span class="comment">// Compile OK     ----（1）</span></span><br><span class="line">        son1.clone(); <span class="comment">// Compile Error     ----（2）</span></span><br><span class="line"></span><br><span class="line">        Son11 son = <span class="keyword">new</span> Son11();    </span><br><span class="line">        son11.f(); <span class="comment">// Compile OK     ----（3）</span></span><br><span class="line">        son11.clone(); <span class="comment">// Compile Error     ----（4）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)(3)：f()从父类Father1处继承，Test1与Father1同包→Compile OK</p>
<p>(2)(4)：clone()从Object类（间接）继承而来，Son1的clone()只有自己以及自己的父类(Father1)可见，Test1不可见→Compile Error</p>
<h3 id="示例二">示例二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="keyword">package</span> p2;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p22;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       MyObject2 obj = <span class="keyword">new</span> MyObject2();</span><br><span class="line">       obj.clone(); <span class="comment">// Compile Error         ----（1）</span></span><br><span class="line"></span><br><span class="line">       Test2 tobj = <span class="keyword">new</span> Test2();</span><br><span class="line">       tobj.clone(); <span class="comment">// Complie OK         ----（2）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()由MyObject2 自己实现，自己以及子类(Test2)可见→Compile Error</p>
<p>(2)：clone()从父类MyObject2继承， 只有自己以及自己的父类(MyObject2)可见→Compile OK</p>
<h3 id="示例三">示例三</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例三</span></span><br><span class="line"><span class="keyword">package</span> p3;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject3</span> <span class="keyword">extends</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p33;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyObject3 obj = <span class="keyword">new</span> MyObject3();</span><br><span class="line">    obj.clone();   <span class="comment">// Compile OK     ------（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()从Object类（间接）继承而来，只有自己以及自己的父类(Test3)可见→Compile OK</p>
<h3 id="示例四">示例四</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例四</span></span><br><span class="line"><span class="keyword">package</span> p4;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject4</span> <span class="keyword">extends</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p44;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyObject4 obj = <span class="keyword">new</span> MyObject4();</span><br><span class="line">    obj.clone(); <span class="comment">// Compile Error      -----（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()由MyObject4自己实现，只有自己、包内以及自己子类可见，Test4是它的父类→Compile Error</p>
<h3 id="示例五">示例五</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例五</span></span><br><span class="line"><span class="keyword">package</span> p5;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       MyObject5 obj = <span class="keyword">new</span> MyObject5();</span><br><span class="line">       obj.clone(); <span class="comment">// Compile OK        ----(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()由MyObject4自己实现，只有自己、包内以及自己子类可见，Test5属于p5→Compile OK</p>
<h3 id="实例六">实例六</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例六</span></span><br><span class="line"><span class="keyword">package</span> p6;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject6</span> <span class="keyword">extends</span> <span class="title">Test6</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject6 obj = <span class="keyword">new</span> MyObject6();</span><br><span class="line">    obj.clone();        <span class="comment">// Compile OK   -------（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()从Object（间接）继承而来，只有自己以及自己的父类(Test6)可见→Compile OK</p>
<h3 id="示例七">示例七</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例七</span></span><br><span class="line"><span class="keyword">package</span> p7;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject7</span> <span class="keyword">extends</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test7 test = <span class="keyword">new</span> Test7();</span><br><span class="line">        test.clone(); <span class="comment">// Compile Error   ----- (1)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()从Object继承而来，只有自己以及自己的父类可见→Compile Error</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
