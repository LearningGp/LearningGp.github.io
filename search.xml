<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>212 单词搜索Ⅱ</title>
    <url>/2020/06/01/212-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2%E2%85%A1/</url>
    <content><![CDATA[<h1 id="单词搜索ii">212 单词搜索II</h1>
<p>难度：困难</p>
<p>平台：leetcode</p>
<h2 id="description">Description</h2>
<p>给定一个二维网格 <strong>board</strong> 和一个字典中的单词列表 <strong>words</strong>，找出所有同时在二维网格和字典中出现的单词。</p>
<p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母在一个单词中不允许被重复使用。</p>
<p><strong>示例:</strong> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入:</span><br><span class="line">words &#x3D; [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;]</span><br><span class="line">board &#x3D;</span><br><span class="line">[</span><br><span class="line"> [&#39;o&#39;,&#39;a&#39;,&#39;a&#39;,&#39;n&#39;],</span><br><span class="line"> [&#39;e&#39;,&#39;t&#39;,&#39;a&#39;,&#39;e&#39;],</span><br><span class="line"> [&#39;i&#39;,&#39;h&#39;,&#39;k&#39;,&#39;r&#39;],</span><br><span class="line"> [&#39;i&#39;,&#39;f&#39;,&#39;l&#39;,&#39;v&#39;]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出:[&quot;eat&quot;,&quot;oath&quot;]</span><br></pre></td></tr></table></figure> <strong>说明:</strong><br />
你可以假设所有输入都由小写字母 <code>a-z</code> 组成。<br />
<a href="https://leetcode-cn.com/problems/word-search-ii/" target="_blank" rel="noopener">原题链接</a></p>
<h2 id="mysolution">MySolution</h2>
<p>这类字符串多模式匹配题目，第一反映是前缀树，关于前缀树在这里就不过多介绍了。此题基本思路是，将words字符串数组构造成前缀树，然后对board的每个字符用前缀树去匹配。当时做这道题花了一定的时间主要是因为用前缀树去匹配时涉及状态回溯，要在每次失败或者结束后回到上一个状态，并且不可遗漏，一开始写题时没有考虑周到。接下来上拆解代码。 ### 结点定义 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</span><br><span class="line">    <span class="comment">//节点结构</span></span><br><span class="line">    ArrayList&lt;node&gt; nodes=<span class="keyword">new</span> ArrayList&lt;node&gt;();</span><br><span class="line">    <span class="keyword">boolean</span> isEnd;</span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">boolean</span> isEnd, <span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造前缀树">构造前缀树</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造前缀树</span></span><br><span class="line">    <span class="keyword">for</span>(String s:words) &#123;</span><br><span class="line">        Solution.node cur=root;</span><br><span class="line">        <span class="keyword">char</span>[] a=s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(Solution.node n:cur.nodes) &#123;</span><br><span class="line">                <span class="keyword">if</span>(n.value==a[i]) &#123;</span><br><span class="line">                    flag=<span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i==a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                        n.isEnd=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cur=n;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                    cur.nodes.add(<span class="keyword">new</span> Solution.node(<span class="keyword">false</span>, a[i]));</span><br><span class="line">                    cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.nodes.add(<span class="keyword">new</span> Solution.node(<span class="keyword">true</span>, a[i]));</span><br><span class="line">                    cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="前缀树匹配">前缀树匹配</h3>
<p>前缀树匹配时采用递归+回溯的思想 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,node cur,<span class="keyword">int</span>[][] visited,String rString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;m &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp;j&lt;n &amp;&amp; visited[i][j]!=<span class="number">1</span>) <span class="comment">//判断边界</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(node n:cur.nodes) <span class="comment">//遍历当前节点子结点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(boards[i][j]!=n.value) <span class="comment">//子节点未找到相同字母</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//子节点找到相同字母</span></span><br><span class="line">            &#123;</span><br><span class="line">                rString+=boards[i][j];<span class="comment">//添加到结果String</span></span><br><span class="line">                <span class="keyword">if</span> (n.isEnd) <span class="comment">//添加到结果String集</span></span><br><span class="line">                    result.add(rString);</span><br><span class="line">                cur=n;<span class="comment">//子节点变成当前结点</span></span><br><span class="line">                <span class="keyword">if</span>(n.nodes.isEmpty()) &#123;</span><br><span class="line">                    visited[i][j]=<span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">                    find(i+x[k], j+y[k], cur, visited, rString);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//查询四周</span></span><br><span class="line">                visited[i][j]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子节点内无相同结点</span></span><br><span class="line">        visited[i][j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="整体代码">整体代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    node root=<span class="keyword">new</span> node(<span class="keyword">false</span>, <span class="string">'*'</span>);</span><br><span class="line">    <span class="keyword">char</span>[][] boards;</span><br><span class="line">    Set&lt;String&gt; result=<span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] x= &#123;<span class="number">0</span>,-<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//负责向四周移动</span></span><br><span class="line">    <span class="keyword">int</span>[] y= &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;<span class="comment">//负责向四周移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m,n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构造前缀树</span></span><br><span class="line">        <span class="keyword">for</span>(String s:words) &#123;</span><br><span class="line">            node cur=root;</span><br><span class="line">            <span class="keyword">char</span>[] a=s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> flag=<span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span>(node n:cur.nodes) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(n.value==a[i]) &#123;</span><br><span class="line">                        flag=<span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">if</span>(i==a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                            n.isEnd=<span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            cur=n;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i!=a.length-<span class="number">1</span>) &#123;</span><br><span class="line">                        cur.nodes.add(<span class="keyword">new</span> node(<span class="keyword">false</span>, a[i]));</span><br><span class="line">                        cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        cur.nodes.add(<span class="keyword">new</span> node(<span class="keyword">true</span>, a[i]));</span><br><span class="line">                        cur=cur.nodes.get(cur.nodes.size()-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,node cur,<span class="keyword">int</span>[][] visited,String rString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;m &amp;&amp; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span> &amp;&amp;j&lt;n &amp;&amp; visited[i][j]!=<span class="number">1</span>) <span class="comment">//判断边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            visited[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(node n:cur.nodes) <span class="comment">//遍历当前节点子结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(boards[i][j]!=n.value) <span class="comment">//子节点未找到相同字母</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="comment">//子节点找到相同字母</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//访问标记</span></span><br><span class="line">                    rString+=boards[i][j];<span class="comment">//添加到结果String</span></span><br><span class="line">                    <span class="keyword">if</span> (n.isEnd) <span class="comment">//添加到结果String集</span></span><br><span class="line">                        result.add(rString);</span><br><span class="line">                    cur=n;<span class="comment">//子节点变成当前结点</span></span><br><span class="line">                    <span class="keyword">if</span>(n.nodes.isEmpty()) &#123;</span><br><span class="line">                        visited[i][j]=<span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;k++) &#123;</span><br><span class="line">                        find(i+x[k], j+y[k], cur, visited, rString);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//查询四周</span></span><br><span class="line">                    visited[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//子节点内无相同结点</span></span><br><span class="line">            visited[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findWords</span><span class="params">(<span class="keyword">char</span>[][] board, String[] words)</span> </span>&#123;</span><br><span class="line">        init(words);</span><br><span class="line">        boards=board;</span><br><span class="line">        m=boards.length;</span><br><span class="line">        n=boards[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span>[][] visited=<span class="keyword">new</span> <span class="keyword">int</span>[board.length][board[<span class="number">0</span>].length];</span><br><span class="line">                String rString=<span class="string">""</span>;</span><br><span class="line">                find(i,j,root,visited,rString);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; ans=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String string : result) &#123;</span><br><span class="line">            ans.add(string);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">node</span></span>&#123;</span><br><span class="line">        <span class="comment">//节点结构</span></span><br><span class="line">        ArrayList&lt;node&gt; nodes=<span class="keyword">new</span> ArrayList&lt;node&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> isEnd;</span><br><span class="line">        <span class="keyword">char</span> value;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">node</span><span class="params">(<span class="keyword">boolean</span> isEnd, <span class="keyword">char</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.isEnd = isEnd;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="有的没的">有的没的</h2>
<p>这一分类主要记录自己做过的一些还比较有意义的题目的解题历程以及一些个人思考，菜鸡起步而已，希望自己能坚持下去，然后能有所进步吧。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>前缀树</tag>
        <tag>困难</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day01</title>
    <url>/2020/08/06/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day01/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day01">ECS 7天实践训练营@day01</h1>
<h2 id="有的没的">有的没的</h2>
<p>最近也是算空闲在家，所以希望能多学点东西，同时期在学习的内容包括网络爬虫、数据分析等，但是觉得内容需要等边学边写到一定阶段后整理个合集在放到博客上，所以这个博客也有一段时间没有更新，东西在写，之后见面。<br />
ECS 7天实践训练营是由阿里云高校计划发起的帮助学生熟悉云上实践的项目，目前个人有一个博客，一个私有网盘跑在云上，希望能探索更多的实践用法，而且加上自己这方面的知识确实比较匮乏，所以报名了这个训练营。<br />
目前第一天体验下来，感觉训练营的课程很详细很实用，确实能让我学习到很多东西，希望自己能继续坚持。</p>
<h2 id="搭建自己专属的静态网站与云笔记">搭建自己专属的静态网站与云笔记</h2>
<p>这是第一天的学习内容，课程主要讲解了两种方案，加上个人在使用的这种方案，接下来对这三种比较容易上手的方案做最粗浅的介绍。</p>
<h3 id="方案一-vuepress">方案一 VuePress</h3>
<h4 id="介绍">介绍</h4>
<p>VuePress是基于Vue的静态网站生成器，主要用于生成技术文档。<br />
主要优点有：</p>
<ul>
<li>界面简洁优雅</li>
<li>容易上手</li>
<li>兼容markdown语法</li>
<li>发布时间新，插件以及主题丰富（个人意见）</li>
</ul>
<h4 id="部署步骤">部署步骤</h4>
<h5 id="开通云服务器">开通云服务器</h5>
<p>本次使用的阿里云的服务器，开通流程非常流畅，基本是跟着指示走即可。需要注意的点有</p>
<ul>
<li>系统尽量选择Centos7，使用范围广，在出现问题时便于查询解决方案</li>
<li>需要在安全组开放用于SSH登录的22端口以及之后网站需要的8080端口</li>
</ul>
<h5 id="安装node.js">安装Node.js</h5>
<ol type="1">
<li><p>登录云服务器，Windows环境下个人推荐Xshell</p></li>
<li><p>通过淘宝镜像下载Node.js 13.9.0 64位安装包（加速下载） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;v13.9.0&#x2F;node-v13.9.0-linux-x64.tar.xz</span><br></pre></td></tr></table></figure></p></li>
<li><p>安装及配置 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 创建安装目录</span><br><span class="line">sudo mkdir -p &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs</span><br><span class="line">2 将⼆进制⽂件解压到要安装⽬录</span><br><span class="line">sudo tar -xJvf node-v13.9.0-linux-x64.tar.xz -C &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs</span><br><span class="line">3 使⽤查看node.js版本号命令验证是否解压成功</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs&#x2F;node-v13.9.0-linux-x64&#x2F;bin</span><br><span class="line">.&#x2F;node -v</span><br><span class="line">4 修改环境变量量，使得能在任意⽬目录下执⾏行行node命令</span><br><span class="line">vim ~&#x2F;.bash_profile</span><br><span class="line">在PATH&#x3D;$PATH:$HOME&#x2F;bin 后⾯面添加路径:&#x2F;usr&#x2F;local&#x2F;lib&#x2F;nodejs&#x2F;node-v13.9.0-linux-x64&#x2F;bin</span><br><span class="line">5 其他路径下验证</span><br><span class="line">node -v</span><br><span class="line">npm version</span><br><span class="line">npx -v</span><br></pre></td></tr></table></figure></p></li>
</ol>
<h5 id="安装vuepress">安装VuePress</h5>
<ol type="1">
<li><p>全局安装（采⽤淘宝镜像） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">npm install -g vuepress</span><br></pre></td></tr></table></figure></p></li>
<li><p>创建目录 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir try_blogs</span><br><span class="line">cd try_blogs</span><br></pre></td></tr></table></figure></p></li>
<li><p>初始化项目 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure> 目录结构 <img src="/2020/08/06/ECS-7天实践训练营-day0/Ms.png" alt="LearningGp" /></p></li>
</ol>
<h5 id="配置vuepress">配置VuePress</h5>
<ol type="1">
<li><p>修改package.json，将scripts内容修改如下 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">	"docs:dev": "vuepress dev docs",</span><br><span class="line">    "docs:build": "vuepress build docs"</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></p></li>
<li><p>根据目录结构创建相关目录及文件 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir docs</span><br><span class="line">cd docs</span><br><span class="line">mkdir .vuepress</span><br><span class="line">echo &#39;# Hello VuePress - first blog!&#39; &gt;README.md</span><br><span class="line">cd .vuepress</span><br><span class="line">echo &gt;config.js</span><br><span class="line">mkdir public</span><br></pre></td></tr></table></figure></p></li>
<li><p>回到try_blogs⽬录，执行命令vuepress dev docs</p></li>
</ol>
<ul>
<li>vuepress dev docs 命令运⾏本地服务，通过访问(http://localhost:8080)即可预览⽹站</li>
<li>vuepress build docs 命令⽤来⽣成静态⽂件， 默认情况下， 放置在docs/.vuepress/dist⽬录中，当然你也可以在docs/.vuepress/config.js中的dest字段来修改默认存放⽬录。</li>
</ul>
<ol start="4" type="1">
<li><p>在浏览器中运⾏：http://ECS公⽹IP:8080。现实如下成功 <img src="/2020/08/06/ECS-7天实践训练营-day0/successed1.png" alt="LearningGp" /></p></li>
<li><p>配置首页，修改READAME.d，将内容改为下图 <img src="/2020/08/06/ECS-7天实践训练营-day0/peizhi.png" alt="LearningGp" /> 刷新浏览器得到新的首页 <img src="/2020/08/06/ECS-7天实践训练营-day0/index2.png" alt="LearningGp" /></p></li>
</ol>
<h3 id="方案二-wordpress">方案二 WordPress</h3>
<h4 id="介绍-1">介绍</h4>
<p>基于 ECS（云服务器）+ CentOS（操作系统）环境，通过部署 LAMP环境并安装 WordPress 快速搭建个人博客。   主要优点有 - 界面简洁优雅 - 容易上手 - 兼容markdown语法 - 自带完善方便的管理界面</p>
<h4 id="部署步骤-1">部署步骤</h4>
<p>阿里云给出了完整的入门场景体验，可以点击链接了解<br />
<a href="https://developer.aliyun.com/adc/scenario/fdecd528be6145dcbe747f0206e361f3?spm=5176.14319553.J_8315879550.2.3c2413bfKDFSk9" target="_blank" rel="noopener">体验链接</a></p>
<figure>
<img src="/2020/08/06/ECS-7天实践训练营-day0/index3.png" alt="" /><figcaption>首页</figcaption>
</figure>
<h3 id="方案三-hexogithub">方案三 Hexo+GitHub</h3>
<h4 id="介绍-2">介绍</h4>
<p>这是我目前使用的方案，也就是这个博客所使用的方案。优点与上两种大致相似，不过由于发布时间较早，现在使用起来有种种小问题需要自行解决，较为麻烦。目前博客集成了浏览统计，文章置顶，next主题，评论功能，后台管理，便签分类等插件。暂时运行良好，不过通过这次学习，正在考虑换成方案一，故在此不再赘述部署步骤等。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>VuePress</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day02</title>
    <url>/2020/08/07/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day02/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day02">ECS 7天实践训练营@day02</h1>
<h2 id="有的没的">有的没的</h2>
<p>第二天的内容是搭建wiki知识库，就是搭建一个私人百科，之前也没有想到过这个想法，不过确实是有实用价值的。课程讲解的很清楚，基本上跟着走就可以完成。不过这个应用对于我个人暂时还没有应用的场景，暂且把搭建方法留存下来备用。</p>
<h2 id="搭建wiki知识库">搭建wiki知识库</h2>
<h3 id="开通云服务器">开通云服务器</h3>
<p>同样采用阿里云的ECS并在安全组中开放http80端口，https443端口，ssh22端口。</p>
<h3 id="安装运行环境">安装运行环境</h3>
<p>这里课程采用的方案是从镜像市场下载LAMP环境（Ubuntu16.04 Apache PHP7.1）镜像，实际操作时没搜到这个，所以用了 LAMP环境（Ubuntu 18.04 Apache PHP7.1）代替。<br />
在阿里云平台上部署镜像有三种方式：</p>
<ul>
<li>购买时直接部署镜像 <img src="/2020/08/07/ECS-7天实践训练营-day0/1.png" alt="LearningGp" /></li>
<li>停止实例后更换操作系统 <img src="/2020/08/07/ECS-7天实践训练营-day0/2.png" alt="LearningGp" /></li>
<li>在<a href="https://market.aliyun.com/products/53398003/cmjj016263.html?spm=5176.10731542.0.0.b6f1677fKwFqek" target="_blank" rel="noopener">镜像页面</a>购买 <img src="/2020/08/07/ECS-7天实践训练营-day0/3.png" alt="LearningGp" /></li>
</ul>
<p>前两种方式需要在后续弹出界面选择需要的镜像</p>
<h3 id="安装mediawiki">安装MediaWiki</h3>
<h4 id="安装远程终端控制和文件传输">安装远程终端控制和文件传输</h4>
<p>课程采用的是PuTTY+FileZiila的方案，这两款比较简洁，适用性高。但是由于个人习惯还是采用了Xshell以及配套的Xftp。</p>
<h4 id="下载mediawiki">下载MediaWiki</h4>
<p><a href="https://releases.wikimedia.org/mediawiki/1.29/mediawiki-1.29.1.tar.gz" target="_blank" rel="noopener">下载MediaWiki并解压缩</a></p>
<h4 id="上传程序文件">上传程序文件</h4>
<ol type="1">
<li>进入 /data/wwwroot/default/ 目录，创建一个old文件夹，将目录上的原始文件全部搬到old内</li>
<li>将解压缩后的MediaWiki程序文件上传至 /data/wwwroot/default/ 目录 <img src="/2020/08/07/ECS-7天实践训练营-day0/e.png" alt="LearningGp" /></li>
<li>使用 chown 命令为目录赋予权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R www &#x2F;data&#x2F;wwwroot&#x2F;default</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="安装mediawiki-1">安装MediaWiki</h4>
<ol type="1">
<li>访问 http://公网IP，点击 【set up the wiki】</li>
<li>根据提示以及自身情况设置，其中有一些注意点</li>
</ol>
<ul>
<li>数据库选择轻量的SQLite<img src="/2020/08/07/ECS-7天实践训练营-day0/6.png" alt="LearningGp" /></li>
<li>刚开始可以跳过高级设置 <img src="/2020/08/07/ECS-7天实践训练营-day0/i.png" alt="LearningGp" /></li>
</ul>
<ol start="3" type="1">
<li>设置完成会生成配置文件LocalSettings.php并提示下载，下载后放入云服务器如图目录下 <img src="/2020/08/07/ECS-7天实践训练营-day0/ime.png" alt="LearningGp" /></li>
<li>重新访问http://公网IP，即可访问首页 <img src="/2020/08/07/ECS-7天实践训练营-day0/index.png" alt="LearningGp" /></li>
</ol>
<h3 id="使用mediawiki">使用MediaWiki</h3>
<h4 id="参数设置">参数设置</h4>
<p>在首页右上角使用管理员账号登录后，点击参数设置即可根据需要更改参数 <img src="/2020/08/07/ECS-7天实践训练营-day0/param.png" alt="LearningGp" /></p>
<h4 id="页面操作">页面操作</h4>
<p>大部分页面操作如编辑、保护、删除等均在页面上点击编辑或是更多即可实现。需要注意的是增加页面的操作。需要将url中的title参数改成词条名，例如http://120.26.163.147/index.php?title=LearningGp 然后点击创建本页面，输入信息后保存即可。 <img src="/2020/08/07/ECS-7天实践训练营-day0/new.png" alt="LearningGp" /></p>
<figure>
<img src="/2020/08/07/ECS-7天实践训练营-day0/name.png" alt="" /><figcaption>LearningGp</figcaption>
</figure>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>MediaWiki</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day03</title>
    <url>/2020/08/08/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day03/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day03">ECS 7天实践训练营@day03</h1>
<h2 id="有的没的">有的没的</h2>
<p>今天的课程总体和昨天的差不大多，不过由于个人暂时没有这方面的需求，所以也只是先做到了安装部署的步骤。前两天的笔记由于GitHub域名解析问题临时放到了csdn，所以今天将博客同时部署到GitHub以及coding，配置了域名的解析，国内的访问会解析到coding的page。个人测试没有啥问题，希望真的没有啥问题。（后续：又出现了问题，coding实在太慢了，现在部署到了云服务器上）开通云服务器、安装运行环境以及上传文件的的操作与昨天的相同，可以点击<a href="https://arvinhe.club/2020/08/07/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day02/#more" target="_blank" rel="noopener">链接</a>查看。</p>
<h2 id="基于云服务器构建微信公众号管理系统">基于云服务器构建微信公众号管理系统</h2>
<h3 id="开通云服务器">开通云服务器</h3>
<p>同样采用阿里云的ECS并在安全组中开放http80端口，https443端口，ssh22端口。</p>
<h3 id="安装运行环境">安装运行环境</h3>
<p>采用LAMP环境（Ubuntu 18.04 Apache PHP7.1）</p>
<h3 id="安装微擎">安装微擎</h3>
<h4 id="前置准备">前置准备</h4>
<p>微擎的install.php做了处理，所以要先去<a href="https://www.w7.cc/" target="_blank" rel="noopener">微擎官网</a>注册账号，然后再<a href="https://cdn.w7.cc/download/WeEngine-Laster-Online.zip" target="_blank" rel="noopener">下载</a>相关文件，并且解压上传到 <img src="/2020/08/08/ECS-7天实践训练营-day0/e.png" alt="LearningGp" /> 然后为目录赋予权限 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R www &#x2F;data&#x2F;wwwroot&#x2F;default</span><br></pre></td></tr></table></figure></p>
<h4 id="创建数据库">创建数据库</h4>
<ol type="1">
<li><p>查询数据库初始密码 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep dbrootpwd &#x2F;root&#x2F;oneinstack&#x2F;options.conf</span><br></pre></td></tr></table></figure> <img src="/2020/08/08/ECS-7天实践训练营-day0/mima.png" alt="LearningGp" /></p></li>
<li><p>浏览器打开http://ecs公网IP/old/phpmyadmin （这里我碰到一个小坑，会显示404，后来发现只要将old中phpMyaAdmin文件夹名称改为全小写字母即可）</p></li>
<li><p>输入 root 账户和密码，点击【执行】进行登录</p></li>
<li><p>在左侧列表点击【new】新建数据库，名称随意</p></li>
</ol>
<h4 id="安装微擎-1">安装微擎</h4>
<ol type="1">
<li><p>浏览器打开http://你的域名/install.php 登陆后进行安装（如果提示拒绝访问，没有权限之类可以再为目录赋予一下权限）</p></li>
<li><p>填写相关信息  - 数据库主机：localhost  - 数据库用户：root  - 数据库密码：之前查询出的密码  - 数据库名称：之前创建的数据库名称  - 表前缀：默认（ims_）</p></li>
</ol>
<h4 id="登录微擎">登录微擎</h4>
<p>访问自己的域名进入登录界面 <img src="/2020/08/08/ECS-7天实践训练营-day0/login.png" alt="LearningGp" /></p>
<p>登录后在左侧平台管理中可以添加平台 <img src="/2020/08/08/ECS-7天实践训练营-day0/pingtai.png" alt="LearningGp" /> 任选一个方式，相关信息可以在自己的公众号平台找到。因为个人暂时没这个需求就不深入了解啦。</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>微擎</tag>
      </tags>
  </entry>
  <entry>
    <title>gitalk Error: Validation Failed</title>
    <url>/2020/05/30/gitalk-Error-Validation-Failed/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这个问题出现在这个博客基本搭建完成后，我发布第三篇文章时，解决的历程不算太困难，但是为了养成记录问题解决过程的习惯（这次就因为没养成习惯错过了截图），还是决定写下来，如果能帮到人就更好了。</p>
<h2 id="问题详情">问题详情</h2>
<p>问题环境：hexo+GitHub+next主题+gitalk<br />
问题描述：页面评论处出现Error: Validation Failed提示</p>
<h2 id="问题分析">问题分析</h2>
<p>在查阅了互联网之后，最后在gitalk的GitHub的<a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">issues</a>中得知主要原因在于gitalk将当前网址作为id属性，并在公开仓库创建相应label的issues实现存储评论，而GitHub限制label长度50从而使得部分文章导致无法创建。</p>
<h2 id="解决方案">解决方案</h2>
<p>比较方便的解决方案主要有以下两种</p>
<h3 id="方案一">方案一</h3>
<h4 id="方案描述">方案描述</h4>
<p>由于编码问题会在网址链接中出现16进制，使其超过长度限制导致无法创建，因此可以调用decodeURI函数，重新编码后用作id属性从而达到缩短的目的。不过该方案存在隐患，即当你的文章链接编码后仍超过限制就会失效，所以我最后没有采用这种方案。</p>
<h4 id="方案实施">方案实施</h4>
<p>找到主题文件路径下的gitalk.swig，我的具体路径为：hexo_third-party，将找到对应代码，将id部分进行如下修改 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">      clientID: &#39;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&#39;,</span><br><span class="line">      clientSecret: &#39;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&#39;,</span><br><span class="line">      repo: &#39;&#123;&#123; theme.gitalk.repo &#125;&#125;&#39;,</span><br><span class="line">      owner: &#39;&#123;&#123; theme.gitalk.githubID &#125;&#125;&#39;,</span><br><span class="line">      admin: [&#39;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&#39;],</span><br><span class="line">      id: location.pathname,</span><br><span class="line">      id: md5(location.pathname),</span><br><span class="line">      distractionFreeMode: &#39;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&#39;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure> <a href="https://blog.csdn.net/qing_gee/article/details/100134998" target="_blank" rel="noopener">方案来源</a></p>
<h3 id="方案二">方案二</h3>
<h4 id="方案描述-1">方案描述</h4>
<p>同方案一，主要目的仍是控制id属性的长度，所以可以采用将location.pathname进行md5加密得到等长字符串作为id，这样就可以无视原本长度将id长度控制在50以内，从而解决问题，本博客最后采用了这个方案。</p>
<h4 id="方案实施-1">方案实施</h4>
<h5 id="添加md5实现">添加md5实现</h5>
<p>这里采用<a href="https://github.com/blueimp/JavaScript-MD5" target="_blank" rel="noopener">blueimp/JavaScript-MD5</a>的代码，在该项目中找到js/md5.min.js。下载后放到主题目录下，我的具体路径为：hexo。 ##### 修改gitalk.swig 找到主题文件路径下的gitalk.swig，我的具体路径为：hexo_third-party。在该文件中加入md5.min.js引用，并对id部分进行修改，将location.pathname进行md5加密后作为id。修改后文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125;</span><br><span class="line">  &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;gitalk&#x2F;dist&#x2F;gitalk.css&quot;&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;https:&#x2F;&#x2F;unpkg.com&#x2F;gitalk&#x2F;dist&#x2F;gitalk.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;gitalk-container&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;script src&#x3D;&quot;&#x2F;js&#x2F;src&#x2F;md5.min.js&quot;&gt;&lt;&#x2F;script&gt; </span><br><span class="line">  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    var gitalk &#x3D; new Gitalk(&#123;</span><br><span class="line">      clientID: &#39;&#123;&#123; theme.gitalk.clientID &#125;&#125;&#39;,</span><br><span class="line">      clientSecret: &#39;&#123;&#123; theme.gitalk.clientSecret &#125;&#125;&#39;,</span><br><span class="line">      repo: &#39;&#123;&#123; theme.gitalk.repo &#125;&#125;&#39;,</span><br><span class="line">      owner: &#39;&#123;&#123; theme.gitalk.owner &#125;&#125;&#39;,</span><br><span class="line">      admin: [&#39;&#123;&#123; theme.gitalk.admin &#125;&#125;&#39;],</span><br><span class="line">      id: md5(location.pathname),</span><br><span class="line">      distractionFreeMode: &#39;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&#39;</span><br><span class="line">    &#125;)</span><br><span class="line">    gitalk.render(&#39;gitalk-container&#39;)</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/death05/article/details/83618887" target="_blank" rel="noopener">方案来源</a></p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/2020/05/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>同计算机网络这篇文章是个人本科期间学习操作系统时用幕布做的笔记，在准备考研时做了些修改，部分略微有些过于具体。同时由于具体格式还没处理的很完美，就先分章节以幕布的链接形式给出,进入链接可以自行展开需要的点。   <em>p.s.参考书目：《操作系统教程》（第5版），费翔林、骆斌编著，高等教育出版社。</em></p>
<h2 id="干货">干货</h2>
<h3 id="知识点思维导图">知识点思维导图</h3>
<p><img src="/2020/05/27/操作系/os.png" /></p>
<h3 id="分章节知识大纲">分章节知识大纲</h3>
<ul>
<li><a href="https://mubu.com/doc/teE-ZHEdWR" target="_blank" rel="noopener">概述</a> 密码: roh7</li>
<li><a href="https://mubu.com/doc/ge2OaWXQaR" target="_blank" rel="noopener">进程、线程与作业</a> 密码: 6mqv</li>
<li><a href="https://mubu.com/doc/6hUG5bKWpqR" target="_blank" rel="noopener">中断与处理机调度</a> 密码: zip9</li>
<li><a href="https://mubu.com/doc/H_hoig98WR" target="_blank" rel="noopener">互斥、同步与通讯</a> 密码: 1rqj</li>
<li><a href="https://mubu.com/doc/6htQwgEnPWR" target="_blank" rel="noopener">死锁与饥饿</a> 密码: yz0v</li>
<li><a href="https://mubu.com/doc/3yI3gEg4MaR" target="_blank" rel="noopener">存储管理</a> 密码: ypqu</li>
<li><a href="https://mubu.com/doc/mp_EIxOqqR" target="_blank" rel="noopener">文件系统</a> 密码: agdg</li>
<li><a href="https://mubu.com/doc/1HUdG8lPcqR" target="_blank" rel="noopener">设备与IO管理</a> 密码: 2701</li>
</ul>
<h3 id="合集">合集</h3>
<ul>
<li><a href="https://mubu.com/doc/5k6-7tXTKWR" target="_blank" rel="noopener">合集</a> 密码: n8io</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>单调栈</title>
    <url>/2020/06/20/%E5%8D%95%E8%B0%83%E6%A0%88/</url>
    <content><![CDATA[<h1 id="单调栈">单调栈</h1>
<h2 id="定义">定义</h2>
<p>单调栈就是满足单调性的栈结构。</p>
<h2 id="性质">性质</h2>
<ul>
<li>单调栈里的元素具有单调性；</li>
<li>每个元素在入栈前，将栈顶破坏栈单调性的元素都出栈；</li>
<li>使用单调栈可以找到入栈时元素向左遍历到的第一个比他小（大）的元素；出栈时元素向右遍历第一个比他小（大）的元素。（做题大多依靠这条性质）</li>
</ul>
<h1 id="例题">例题</h1>
<h2 id="每日温度">739 每日温度</h2>
<h3 id="题目描述">题目描述</h3>
<p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p>
<p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p>
<p><a href="https://leetcode-cn.com/problems/daily-temperatures" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="解释">解释</h3>
<p>这道题思路比较明显，找每一个数右边第一个比他大的数。所以可以使用单调栈实现。</p>
<h3 id="代码">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        Deque&lt;Integer&gt; I=<span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] result=<span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">if</span> (T.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        I.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;T.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tempT=T[i];</span><br><span class="line">            <span class="keyword">while</span> (!I.isEmpty() &amp;&amp; T[I.getLast()]&lt;tempT)&#123;</span><br><span class="line">                <span class="keyword">int</span> pI=I.removeLast();</span><br><span class="line">                result[pI]=i-pI;</span><br><span class="line">            &#125;</span><br><span class="line">            I.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!I.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i:I</span><br><span class="line">                 ) &#123;</span><br><span class="line">                result[i]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="柱状图中最大的矩形">84 柱状图中最大的矩形</h2>
<h3 id="题目描述-1">题目描述</h3>
<p>给定n个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1。求在该柱状图中，能够勾勒出来的矩形的最大面积。  </p>
<p><img src="/2020/06/20/单调/1.png" alt="LearningGp" /> 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。</p>
<p><img src="/2020/06/20/单调/2.png" alt="overwrote existing file" /> 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10个单位。 <a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="解释-1">解释</h3>
<p>每个能勾勒出的矩形其实可以理解成为其中最短的一个柱体向左右拓展。所以暴力枚举方法为:</p>
<ul>
<li>枚举某一柱子</li>
<li>向左右拓展直到遇到高度小于其的柱子停止</li>
<li>计算面积</li>
</ul>
<p>但是我们可以发现这边其实要找的就是某一柱子的左边以及右边第一个比它矮的柱子，这个需求非常符合单调栈的第三条性质。所以这题可以使用单调栈来优化解决。将每个柱体依次入栈，若当前的柱体高度大于等于栈顶柱体的高度，就直接将当前柱体入栈，否则当前栈顶的柱体就找到了右边的第一个小于自身的柱体（右边界），而对栈中柱体来说，栈中的下一个柱体就是其左边第一个小于自身的柱体（左边界）那么就可以将栈顶柱体出栈并计算面积。</p>
<h3 id="代码-1">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(right, n);</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i]) &#123;</span><br><span class="line">                right[stack.peek()] = i;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = (stack.isEmpty() ? -<span class="number">1</span> : stack.peek());</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            ans = Math.max(ans, (right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="接雨水">42 接雨水</h2>
<h3 id="题目描述-2">题目描述</h3>
<p>给定n个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。  </p>
<p><img src="/2020/06/20/单调/3.png" alt="LearningGp" /> <strong>示例:</strong> <strong>输入:</strong> [0,1,0,2,1,0,1,3,2,1,2,1] <strong>输出:</strong> 6 <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="解释-2">解释</h3>
<p>这题依旧可以看出是寻找边界的题目。栈顶元素是左边界，当前柱体是右边界，当前高度是两者高度中的较小者减去计算过的高度。<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/dan-diao-zhan-jie-jue-jie-yu-shui-wen-ti-by-sweeti/" target="_blank" rel="noopener">详解来自Sweetiee</a></p>
<h3 id="代码-2">代码</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历每个柱子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; height.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> leftMax = <span class="number">0</span>, rightMax = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 计算当前柱子左侧的柱子中的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                leftMax = Math.max(leftMax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算当前柱子右侧的柱子中的最大高度</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; height.length; j++) &#123;</span><br><span class="line">                rightMax = Math.max(rightMax, height[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 结果中累加当前柱子顶部可以储水的高度，</span></span><br><span class="line">            <span class="comment">// 即 当前柱子左右两边最大高度的较小者 - 当前柱子的高度。</span></span><br><span class="line">            res += Math.min(leftMax, rightMax) - height[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="关于deque">关于Deque</h1>
<p>在这篇文章给出的代码中有些使用了Deque代替stack，或是对Deque进行一次封装代替stack。原先的stack不符合OOP设计原则。虽然stack仍未被弃用，且在算法题中影响不大，但是确实Deque作为双端队列更加方便，但如果出于封装性的考虑，可以对Deque再做一次封装，限制非栈操作。<a href="https://mp.weixin.qq.com/s/Ba8jrULf8NJbENK6WGrVWg" target="_blank" rel="noopener">详细解释</a></p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>单调栈</tag>
      </tags>
  </entry>
  <entry>
    <title>起点</title>
    <url>/2020/05/25/%E8%B5%B7%E7%82%B9/</url>
    <content><![CDATA[<h3 id="有的没的">有的没的</h3>
<p>搭建个人博客的念头也是早就有了，就是一直没有这个时间或是契机吧，各种个人笔记和刷题笔记都散落在不同的应用里，感觉有些杂乱而且浪费。所以趁这段时间将这个博客搭了起来，之前的各种笔记都会慢慢搬到这里，即便没人看，也权当是自己的仓库，记录自己的技术成长吧。暂时用LearningGp作为博客名，这个名字最早是游戏角色的名字LearningGroup但是因为那个游戏有长度限制，就变成了现在这样。游戏倒是没在玩了，名字倒是留下了。希望能把这个小地方一直做下去吧。</p>
<h3 id="规划">规划</h3>
<p>目前已经想好分类如下</p>
<ul>
<li>刷题记录——主要记录算法题题解</li>
<li>知识图谱——主要记录学过科目的知识图谱</li>
<li>踩坑记录——各种踩过的解决的没解决的坑</li>
<li>随笔——一些有的没的</li>
</ul>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2020/05/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这篇文章是个人本科期间学习计算机网络时用幕布做的笔记，在准备考研时做了些修改，部分略微有些过于具体。同时由于具体格式还没处理的很完美，就先分章节以幕布的链接形式给出,进入链接可以自行展开需要的点。<br />
<em>p.s.参考书目：《计算机网络》（第7版），谢希仁著，电子工业出版社。</em></p>
<h2 id="干货">干货</h2>
<h3 id="知识点思维导图">知识点思维导图</h3>
<p><img src="/2020/05/26/计算机网/network.png" /></p>
<h3 id="分章节知识大纲">分章节知识大纲</h3>
<ul>
<li><a href="https://mubu.com/doc/gqn4PLygh0" target="_blank" rel="noopener">概述</a> 密码: 4igo</li>
<li><a href="https://mubu.com/doc/6o91f8PaWVR" target="_blank" rel="noopener">应用层</a> 密码: 2m1h</li>
<li><a href="https://mubu.com/doc/6-KYTSqvOVR" target="_blank" rel="noopener">运输层</a> 密码: 9uot</li>
<li><a href="https://mubu.com/doc/1sETTUIvH9R" target="_blank" rel="noopener">网络层</a> 密码: 4mk7</li>
<li><a href="https://mubu.com/doc/2nnoStqrP9R" target="_blank" rel="noopener">数据链路层</a> 密码: 0n0g</li>
<li><a href="https://mubu.com/doc/17eAGAnsMpR" target="_blank" rel="noopener">物理层</a> 密码: cjd3</li>
<li><a href="https://mubu.com/doc/5gRz5-bMwFR" target="_blank" rel="noopener">无线网络</a> 密码: zjwe</li>
<li><a href="https://mubu.com/doc/3qkfIGReLFR" target="_blank" rel="noopener">杂</a> 密码: uota</li>
</ul>
<h3 id="合集">合集</h3>
<ul>
<li><a href="https://mubu.com/doc/5ShTlP-750" target="_blank" rel="noopener">合集</a> 密码: vkai</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>阅读的逻辑</title>
    <url>/2020/05/27/%E9%98%85%E8%AF%BB%E7%9A%84%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这篇笔记是准备考研时在学习唐迟老师英语阅读课程时记下的，感觉上老师的这种基于逻辑的做题思路对于考试或是读英文论文都有较大帮助，不过笔记主要服务于考试。具体的思想可以去唐老师课上体会。</p>
<h2 id="大原则">大原则</h2>
<h3 id="时间对比原则">时间对比原则</h3>
<ul>
<li>过去不重要，现在才重要，本质是转折（特别注意末端转折）</li>
<li>Used to be（过去常常，潜台词现在已经不这样）</li>
<li>traditional（时间对比，表示过去）</li>
<li>No longer；while；today</li>
<li>Now 后面要么是全文中心，要么是题目的答案</li>
</ul>
<h3 id="把握作者态度">把握作者态度</h3>
<ul>
<li>逻辑</li>
<li>（形容词，副词）正向，负向态度</li>
<li>同义替换</li>
<li>中心、主旨（串线；中心句；中心词）</li>
</ul>
<h2 id="题型">题型</h2>
<h3 id="细节题">细节题</h3>
<ul>
<li>定位好的句子是解题的重要依据</li>
</ul>
<h3 id="中心思想主旨题">中心思想/主旨题</h3>
<ul>
<li>标志
<ul>
<li>Mainly about/discuss</li>
<li>The best title/ a appropriate title</li>
<li>The purpose</li>
</ul></li>
<li>方法
<ul>
<li>串线（最普适）：将各段首末句串联成一个整体，注意转折处；（80%看首句）</li>
<li>中心词（最直观）：文中反复高频出现的词（包括同义替换）；</li>
<li>中心句（最需要练习）：
<ul>
<li>①问题开头的提问的回答；--好奇害死猫</li>
<li>②独句段（独句段不一定短）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="作者态度题">作者态度题</h3>
<ul>
<li>标志
<ul>
<li>attitude deem consider tone</li>
</ul></li>
<li>方法
<ul>
<li>正面：positive optimistic approval suppportive</li>
<li>负面：negative pessimistic disapproval critical doubtful suspicious skeptical quentionable</li>
<li>中性：neutral objective impartial disinterested</li>
<li>注：critical adj.重要的；批评的be critical of</li>
</ul></li>
<li>小墓碑选项
<ul>
<li>漠不关心的：uninterested unconcerned indifferent</li>
<li>困惑的：confused puzzled</li>
<li>偏见的：biased prejudice contemptuous subjective</li>
<li>基本不选择</li>
</ul></li>
<li>当作者的态度没有明确提出时
<ul>
<li>文章的框架（串线——中心/态度）</li>
<li>adj./adv. （感情色彩强烈的，尤其是修饰主题词的）</li>
<li>转折处</li>
<li>情态动词之后（should/must/could/may/might/need……）</li>
</ul></li>
</ul>
<h3 id="推测词意">推测词意</h3>
<ul>
<li>方法
<ul>
<li>上下文（本句内）逻辑关系，提炼出不断重复的内容（被不断重复的同义词、近义词、but之后的反义词）</li>
<li>排除表面意思</li>
<li>全文中心主旨</li>
</ul></li>
</ul>
<h3 id="例证题">例证题</h3>
<ul>
<li>标志
<ul>
<li>example case illustrate demonstrate to show to_______</li>
</ul></li>
<li>例子本身不重要，重要的是例子所支持的观点
<ul>
<li>观点一般在例子前，有时也在例子后。（找到正确的）</li>
<li>干扰选项：就事论事 ——讲例子本身（排除错误的）</li>
</ul></li>
<li>观点出现位置
<ul>
<li>转折</li>
<li>感情色彩强的词（例子是客观的）</li>
<li>情态动词（shuld could ）</li>
<li>I/we</li>
</ul></li>
</ul>
<h3 id="推理题">推理题</h3>
<ul>
<li>标志
<ul>
<li>infer imply suggest learn from</li>
</ul></li>
<li>方法
<ul>
<li>细节 + 主旨 + 逻辑</li>
<li>排除细节重复错误的选项</li>
<li>干扰选项特征：貌似相关，无中生有</li>
</ul></li>
</ul>
<h2 id="小技巧">小技巧</h2>
<ul>
<li>串题干
<ul>
<li>只看题干，不看选项，把握大体内容</li>
</ul></li>
<li>注意同义替换</li>
<li>逻辑提示词
<ul>
<li>时间，转折，情感色彩形容词、副词</li>
</ul></li>
<li>While
<ul>
<li>80%考察对比，翻译为尽管</li>
</ul></li>
<li>But
<ul>
<li>多数用于表递进</li>
</ul></li>
<li>代词指代
<ul>
<li>帮助理解概念性含义</li>
<li>出现在一个新的名词前时，那么这个名词一定是前面某一个词的同义替换</li>
<li>优先指代上文中心（再考虑就近原则）</li>
</ul></li>
<li>反复强调的是重点，重点是考点</li>
<li>选项中需要注意的用词
<ul>
<li>绝对化用词（文中做标记）</li>
<li>比较级</li>
</ul></li>
<li>干扰选项一定是围绕正确选项来设计的，做题时可以去除意思相同词语，只关注区别</li>
<li>转折处常做正确答案命题点</li>
<li>三要素
<ul>
<li>逻辑</li>
<li>情感</li>
<li>同义替换</li>
</ul></li>
<li>注意“？”</li>
<li>单独的数字是没有意义的，重要的是对比的数字</li>
<li>作者态度题题干中的词一定是中心话题的组成部分</li>
<li>细节服务主旨</li>
<li>instead单独使用时，上下文表示相同逻辑</li>
<li>Instead of 前后部分相反</li>
<li>出题顺序与行文顺序一致</li>
<li>A与B互为相反，很有可能有一个是正确答案</li>
<li>少数派往往是重要的</li>
<li>当题干明确告诉考虑两段，注意考察的是交集</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程</title>
    <url>/2020/05/30/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="有的没的">有的没的</h2>
<p>这篇文章是个人研究生初试学习软件工程时用幕布做的笔记，同时也加入了一些搜集于其他书本以及网络的内容。《软件工程与计算：软件开发的技术基础》这本书个人感觉内容过于丰富充实，再学习时很有压力且容易流于表面。需要补充许多另外的知识与思想，有条件的话推荐搭配南大本科相关课程视频，收益良多。同时由于具体格式还没处理的很完美，就先以幕布的链接形式给出,进入链接可以自行展开需要的点。   <em>p.s.主要参考书目：《软件工程与计算：软件开发的技术基础》，骆斌主编、丁二玉、刘钦编著，机械工业出版社。</em></p>
<h2 id="干货">干货</h2>
<h3 id="知识点思维导图">知识点思维导图</h3>
<p><img src="/2020/05/30/软件工/software.png" /></p>
<h3 id="合集">合集</h3>
<ul>
<li><a href="https://mubu.com/doc/3NhfNkdYONR" target="_blank" rel="noopener">合集</a> 密码: ko0y</li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题64 求1+2+...+n</title>
    <url>/2020/06/02/%E9%9D%A2%E8%AF%95%E9%A2%9864-%E6%B1%821-2-n/</url>
    <content><![CDATA[<h1 id="面试题64-求12...n">面试题64 求1+2+...+n</h1>
<p>难度：中等</p>
<p>平台：leetcode</p>
<h2 id="description">Description</h2>
<p>求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例 1：</p>
<p>输入: n = 3 输出: 6 示例 2：</p>
<p>输入: n = 9 输出: 45</p>
<p>限制：</p>
<p>1 &lt;= n &lt;= 10000</p>
<p><a href="https://leetcode-cn.com/problems/qiu-12n-lcof" target="_blank" rel="noopener">https://leetcode-cn.com/problems/qiu-12n-lcof</a></p>
<h2 id="mysolution">MySolution</h2>
<p>这道题算是一股清流，所以记录下来。刚看到题有点懵，先想到的是求和公式<strong>n*(n+1)/2</strong>但是不能用乘除法，除2操作可以用&gt;&gt;=1代替，但是<strong>n*(n+1)</strong>一下子没有想到代替的办法（后来在题解中找到，本文作为其他解法给出）在公式法无法进行时想到了递归法，因为递归出口可以用&amp;&amp;的一个性质实现——如果左边为假便不判断右边表达式（后来在题解里发现这个称为逻辑运算符的短路性质,||也有类似性质）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> f;</span><br><span class="line">        f = n &gt; <span class="number">0</span> &amp;&amp; (n += sumNums(n - <span class="number">1</span>)) &gt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="othersolutions">OtherSolutions</h2>
<p>接之前讲的公式法，在实现<strong>n*(n+1)</strong>时用到了<a href="http://mathforum.org/dr.math/faq/faq.peasant.html" target="_blank" rel="noopener">俄罗斯农民乘法</a>，原理简单来说就是若<strong>A*B</strong>，我们将<strong>A*2</strong>作为新A的同时<strong>B/2</strong>作为新B，如果原B为偶数则由于乘法交换律结果不变，如果原B为奇数由于自动取下界我们则丢失了一个原A，需要在最后结果补上一个原A。如此反复到B为1，此时补上所有中途丢失的数即为结果。对应到2进制，我们可以用左移一位和右移一位代替<strong>*2</strong>与<strong>/2</strong>操作，B的二进制展开是否为1作为是否需补的标志，同时由于不能使用循环，结合数据范围，我们需要手动展开14位最终实现求和公式<strong>n*(n+1)/2</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, A = n, B = n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        flag = ((B &amp; <span class="number">1</span>) &gt; <span class="number">0</span>) &amp;&amp; (ans += A) &gt; <span class="number">0</span>;</span><br><span class="line">        A &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        B &gt;&gt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://leetcode-cn.com/problems/qiu-12n-lcof/solution/qiu-12n-by-leetcode-solution/" target="_blank" rel="noopener">LeetCode-Solution</a></p>
<h2 id="有的没的">有的没的</h2>
<p>通过这道题，发现自己对于位运算的知识不熟悉，解题时不能及时想到。可见还有许多这样平时不常常接触但是有用的知识点需要我去熟悉。</p>
]]></content>
      <categories>
        <category>刷题记录</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>中等</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day05</title>
    <url>/2020/08/10/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day05/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day05">ECS 7天实践训练营@day05</h1>
<h2 id="有的没的">有的没的</h2>
<p>昨天的课程是在线编程比赛，成绩不太满意感觉退步蛮多，最近也确实没有好好刷算法，还是得多花些时间在算法上。今天的课程是搭建Java Web开发环境。因为之前做过Java Web的项目，所以都还算熟悉。课程讲的很详细，也是跟着做就ok。<a href="https://developer.aliyun.com/adc/scenario/bbad6f5e0cba4c0ba5c904f6cf06a8d0" target="_blank" rel="noopener">体验链接</a></p>
<h2 id="搭建java-web开发环境">搭建Java Web开发环境</h2>
<p>Java Web开发环境最基础的就是JDK+MySQL+TomCat，基本流程就是按顺序安装即可。</p>
<h3 id="创建资源连接云服务器">创建资源&amp;连接云服务器</h3>
<p>这两个步骤与之前没有差别，就不再赘述。</p>
<h3 id="安装jdk">安装JDK</h3>
<ol type="1">
<li><p>执行以下命令，查看yum源中JDK版本 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list java*</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，使用yum安装JDK1.8 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install java-1.8.0-openjdk*</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，查看是否安装成功 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure> <img src="/2020/08/10/ECS-7天实践训练营-day0/java.png" alt="LearningGp" /></p></li>
</ol>
<h3 id="安装mysql数据库">安装MySQL数据库</h3>
<ol type="1">
<li><p>依次执行下方命令，下载并安装MySQL官方的Yum Repository <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql57-community-release-el7-10.noarch.rpm</span><br><span class="line">yum -y install mysql-community-server</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，启动 MySQL 数据库 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld.service</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，查看MySQL初始密码(最后的即为密码) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep &quot;password&quot; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br></pre></td></tr></table></figure> <img src="/2020/08/10/ECS-7天实践训练营-day0/mysql.png" alt="LearningGp" /></p></li>
<li><p>执行以下命令,输入前面获取的密码，登录数据库（出现mysql&gt;即为登录成功） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，修改MySQL默认密码(也可以不输入第一行，第二行将密码改为符合原密码安全策略的复杂密码) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy&#x3D;0;  #修改密码安全策略为低（只校验密码长度，至少8位）。</span><br><span class="line">ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;12345678&#39;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，授予root用户远程管理权限(熟悉mysql的可以为项目建立对应用户，授予相应用户相应的远程权限) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;%&#39; IDENTIFIED BY &#39;12345678&#39;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>输入exit退出数据库</p></li>
</ol>
<h3 id="安装tomcat">安装Tomcat</h3>
<ol type="1">
<li><p>执行以下命令，下载Tomcat压缩包 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-8&#x2F;v8.5.57&#x2F;bin&#x2F;apache-tomcat-8.5.57.tar.gz</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，解压刚刚下载Tomcat包 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-8.5.57.tar.gz</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，修改Tomcat名字(方便操作) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv apache-tomcat-8.5.57 &#x2F;usr&#x2F;local&#x2F;Tomcat8.5</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，为Tomcat授权 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;usr&#x2F;local&#x2F;Tomcat8.5&#x2F;bin&#x2F;*.sh</span><br></pre></td></tr></table></figure></p></li>
<li><p>执行以下命令，修改Tomcat默认端口号为80（主要是为了能够输入地址直接访问而不用输入端口号） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed -i &#39;s&#x2F;Connector port&#x3D;&quot;8080&quot;&#x2F;Connector port&#x3D;&quot;80&quot;&#x2F;&#39; &#x2F;usr&#x2F;local&#x2F;Tomcat8.5&#x2F;conf&#x2F;server.xml</span><br></pre></td></tr></table></figure></p></li>
<li><p>启动Tomcat(为了方便也可以将其添加为服务) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;Tomcat8.5&#x2F;bin&#x2F;.&#x2F;startup.sh</span><br></pre></td></tr></table></figure> ### 访问Tomcat 打开浏览器，在地址栏中输入ECS公网地址，如显示下图界面，则搭建完成 <img src="/2020/08/10/ECS-7天实践训练营-day0/tomcat.png" alt="LearningGp" /></p></li>
</ol>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>ECS 7天实践训练营@day06</title>
    <url>/2020/08/11/ECS-7%E5%A4%A9%E5%AE%9E%E8%B7%B5%E8%AE%AD%E7%BB%83%E8%90%A5-day06/</url>
    <content><![CDATA[<h1 id="ecs-7天实践训练营day06">ECS 7天实践训练营@day06</h1>
<h2 id="有的没的">有的没的</h2>
<p>今天的课程是搭建离线下载服务器，主要用于帮助我们离线下载一些网络资源，方便我们直接从服务器取用，在服务器网络带宽够大的情况下，能帮助我们下载比较大的文件。流程依旧讲解的很清楚，跟着做基本没有问题。今天是训练营最后一天了，总体下来收获还是挺多的，之后的几天会好好考虑怎么更好的利用云服务器来方便生活学习。</p>
<h2 id="打造离线下载服务器">打造离线下载服务器</h2>
<h3 id="创建资源连接云服务器">创建资源&amp;连接云服务器</h3>
<p>这两个步骤与之前没有差别，就不再赘述。(安全组处需要开启6080端口)</p>
<h3 id="下载安装ccaa方案包">下载安装CCAA方案包</h3>
<ol type="1">
<li><p>输入命令下载（完成后自动开始安装） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#国内服务器</span><br><span class="line">bash &lt;(curl -Lsk</span><br><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helloxz&#x2F;ccaa&#x2F;master&#x2F;ccaa.sh) cdn</span><br><span class="line">#海外服务器</span><br><span class="line">bash &lt;(curl -Lsk</span><br><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;helloxz&#x2F;ccaa&#x2F;master&#x2F;ccaa.sh)</span><br></pre></td></tr></table></figure></p></li>
<li><p>输入1安装CCAA <img src="/2020/08/11/ECS-7天实践训练营-day0/2.png" alt="LearningGp" /></p></li>
<li><p>设置下载路径，可以直接回车 <img src="/2020/08/11/ECS-7天实践训练营-day0/3.png" alt="LearningGp" /></p></li>
<li><p>输⼊ Aria2 的 RPC 通信密钥，输⼊不含特殊字符的内容即可 <img src="/2020/08/11/ECS-7天实践训练营-day0/4.png" alt="LearningGp" /></p></li>
<li><p>安装成功 <img src="/2020/08/11/ECS-7天实践训练营-day0/5.png" alt="LearningGp" /></p></li>
<li><p>设置 浏览器打开上一步显示的url，进入设置，填写密钥后点击重新载入即可 <img src="/2020/08/11/ECS-7天实践训练营-day0/6e.png" alt="overwrote existing file" /></p></li>
</ol>
<h3 id="使用离线下载服务器">使用离线下载服务器</h3>
<h4 id="常用命令">常用命令</h4>
<ul>
<li>ccaa:进⼊CCAA操作界⾯</li>
<li>ccaa status:查看CCAA运⾏状态</li>
<li>ccaa stop:停⽌CCAA</li>
<li>ccaa start:启动CCAA</li>
<li>ccaa restart:重启CCAA</li>
<li>ccaa -v:查看CCAA版本（2.0开始⽀持）</li>
</ul>
<h4 id="离线下载">离线下载</h4>
<p>界面其实比较容易理解，点击新建后输入下载链接，分行可输入多个链接后点击立即下载即可，也可以上传种子文件。</p>
<h4 id="下载至本地">下载至本地</h4>
<p>在文件管理中选中所需要的文件，点击下载即可（推荐按量付费的云服务器，可以保证速度）</p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>ECS</tag>
        <tag>CCAA</tag>
      </tags>
  </entry>
  <entry>
    <title>网络爬虫笔记</title>
    <url>/2020/10/21/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="爬虫笔记">爬虫笔记</h1>
<h2 id="有的没的">有的没的</h2>
<p>这个笔记是一个目录性质的笔记，主要是方便自己日后回忆，如果有有缘的大兄弟也学习了这套课程，欢迎交流。这套课程感觉还是挺实用的，在学习过程中也试着解决了一些正好遇到的需求。课程在B站上有（路飞学城）。<br />
自己学习过程中写的相关代码都push到了自己的<a href="https://github.com/LearningGp/WebCrawler" target="_blank" rel="noopener">GitHub</a>上，可以自由查阅。之后可能也会就一些部分写详细的学习笔记。</p>
<h2 id="http">http</h2>
<h3 id="常用请求头信息">常用请求头信息</h3>
<ul>
<li>User-Agent：请求载体的身份标识</li>
<li>Connection：请求完毕后，是否保持连接</li>
</ul>
<h3 id="常用响应头信息">常用响应头信息</h3>
<ul>
<li>Content-Type：服务器响应回客户端的数据类型</li>
</ul>
<h2 id="https">https</h2>
<p>安全的超文本传输协议</p>
<h3 id="加密方式">加密方式</h3>
<ul>
<li>对称密钥加密</li>
<li>非对称密钥加密</li>
<li>证书密钥加密（https）</li>
</ul>
<h2 id="requests模块">requests模块</h2>
<p>python中原生的基于网络请求的模块，用于模拟浏览器发请求。</p>
<h3 id="流程">流程</h3>
<ul>
<li>指定url</li>
<li>发起请求</li>
<li>获取响应数据</li>
<li>持久化存储</li>
</ul>
<h3 id="实例">实例</h3>
<ul>
<li><p>例1 爬取百度首页</p></li>
<li><p>例2 爬取百度查询页面</p></li>
<li><p>例3 爬取百度翻译结果</p></li>
<li><p>例4 爬取豆瓣电影排名</p></li>
<li><p>练习 爬取KFC餐厅地址</p></li>
<li><p>例5 爬取药监局网站信息</p></li>
</ul>
<h2 id="聚焦爬虫">聚焦爬虫</h2>
<h3 id="流程-1">流程</h3>
<ul>
<li>指定url</li>
<li>发起请求</li>
<li>获取响应数据</li>
<li>数据解析</li>
<li>持久化存储</li>
</ul>
<h3 id="实现">实现</h3>
<h4 id="正则">正则</h4>
<p>利用正则表达式从爬取的数据中匹配出我们所需要的部分</p>
<h5 id="常用表达式">常用表达式</h5>
<figure>
<img src="/2020/10/21/网络爬虫笔/zhengze.png" alt="" /><figcaption>LearningGp</figcaption>
</figure>
<h5 id="实例-爬取糗事百科图片">实例 爬取糗事百科图片</h5>
<h4 id="bs4">bs4</h4>
<h5 id="步骤简介">步骤简介</h5>
<ol type="1">
<li>实例化BeautifulSoup对象</li>
<li>将页面源码数据加载到该对象中</li>
<li>通过BeautifulSoup对象的属性或方法定位标签以及数据提取</li>
</ol>
<h5 id="数据解析相关方法和属性">数据解析相关方法和属性</h5>
<ul>
<li>tagName：返回html中第一次出现的tagName标签</li>
<li>find():
<ul>
<li>find('tagName')：返回html中第一次出现的tagName标签</li>
<li>find('tagName',class_/id/attr='xxx' ):属性定位</li>
</ul></li>
<li>find_all()：同find，但是返回所有符合条件项（列表）</li>
<li>select()：
<ul>
<li>select('某种选择器（id，class，标签）')：返回列表</li>
<li>select('用&gt;以及空格连接的多个选择器组成层级选择器')：返回列表（&gt;表示一个层级，空格表示多个层级）</li>
</ul></li>
<li>获取标签之间的文本数据
<ul>
<li>text/string/get_text()
<ul>
<li>text/get_text()：获取所定位标签下所有文本</li>
<li>string：只获取所定位标签下直系文本</li>
</ul></li>
</ul></li>
<li>获取标签中的属性值
<ul>
<li>['标签名']</li>
</ul></li>
</ul>
<h5 id="实例-爬取三国演义所以章节标题和内容">实例 爬取三国演义所以章节标题和内容</h5>
<h4 id="xpath">xpath</h4>
<p>最常用且最便捷高效的解析方式，同时具有较好的通用性</p>
<h5 id="步骤简介-1">步骤简介</h5>
<ol type="1">
<li>实例化etree的对象
<ul>
<li>加载本地文档：etree.parse(filePath)</li>
<li>加载网络上获取的源码数据：etree.HTML('page_text')</li>
</ul></li>
<li>将页面源码数据加载到该对象中</li>
<li>调用rtree对象中的xpath方法结合着xpath表达式实现标签的定位和内容的捕获</li>
</ol>
<h4 id="xpath表达式">xpath表达式</h4>
<p>返回基本为列表，定位阶段列表内为对象（tips：谷歌浏览器F12下，Elemens窗口下选中需要的标签右键-&gt;copy-&gt;copy Xpath 可以复制对应Xpath，按需修改） - 标签定位：'/html/head/title'（层级定位） - /：表示一个层级 - //：表示多个层级，或表示从任意位置开始定位 - 属性定位：'//div<span class="citation" data-cites="class">[@class="song"]</span>' - 索引定位：'//div<span class="citation" data-cites="class">[@class="song"]</span>/p[3]'（该div下第三个p标签，从1开始） - 取文本：'/html/head/title/text()' - 取属性：'//div<span class="citation" data-cites="class">[@class="song"]</span>/img/<span class="citation" data-cites="src">@src</span>'</p>
<h4 id="实例-1">实例</h4>
<ul>
<li><p>实例1 爬取58同城二手房标题</p></li>
<li><p>实例2 爬取图片</p></li>
<li><p>实例3 爬取城市名称</p></li>
<li><p>练习1 爬取简历模板</p></li>
</ul>
<h2 id="验证码识别">验证码识别</h2>
<h3 id="简介">简介</h3>
<p>这边采用将验证码图片下载下来后调用第三方识别服务进行识别，本文采用超级鹰的服务，需要提前前往其网站注册账号并充值。</p>
<h3 id="实例-2">实例</h3>
<ul>
<li><p>实例1 超级鹰服务测试</p></li>
<li><p>实例2 古诗文网站验证码识别</p></li>
</ul>
<h2 id="代理爬虫">代理爬虫</h2>
<h3 id="简介-1">简介</h3>
<p>主要作用有</p>
<ol type="1">
<li>突破自身IP访问的限制</li>
<li>隐藏自身真实IP</li>
</ol>
<p>代理相关工具网站</p>
<ul>
<li>快代理</li>
<li>西祠代理</li>
<li>www.goubanjia.com</li>
</ul>
<h3 id="实现-1">实现</h3>
<h4 id="实例-代理爬虫查询ip">实例 代理爬虫查询IP</h4>
<h2 id="异步爬虫">异步爬虫</h2>
<h3 id="简介-2">简介</h3>
<p>单线程串行的方式爬取效率较低，需要我们通过一些方法实现异步爬虫。</p>
<h3 id="实现方式">实现方式</h3>
<ul>
<li>多线程，多进程（不推荐）
<ul>
<li>好处 ：为相关的阻塞操作开启线程或进程，阻塞操作就可以异步执行</li>
<li>弊端：无法无限制开启多线程或多进程</li>
</ul></li>
<li>线程池、进程池（适当使用）
<ul>
<li>好处：降低系统对进程或者线程创建和销毁的频率，降低系统开销</li>
<li>弊端：池中线程或进程的数量有上限</li>
</ul></li>
<li>单线程+异步协程（推荐）
<ul>
<li>使用asyncio以及aiohttp实现</li>
</ul></li>
</ul>
<h2 id="selenium模块">selenium模块</h2>
<h3 id="简介-3">简介</h3>
<p>是一个自动化测试工具,而爬虫中使用它主要是为了解决requests无法直接执行JavaScript代码的问题 selenium本质是通过驱动浏览器，完全模拟浏览器的操作，比如跳转、输入、点击、下拉等，来拿到网页渲染之后的结果，可支持多种浏览器</p>
<h3 id="实例-3">实例</h3>
<ul>
<li>例1 人人网模拟登录</li>
</ul>
<h2 id="scrapy框架">scrapy框架</h2>
<h3 id="简介-4">简介</h3>
<p>一个为了爬取网站数据，提取结构性数据而编写的应用框架。其内部已经被集成了各种功能（高性能异步下载，队列，分布式，解析，持久化等）。</p>
<h3 id="流程-2">流程</h3>
<ul>
<li>创建工程：
<ul>
<li>scrapy startproject ProName</li>
</ul></li>
<li>进入工程目录：
<ul>
<li>cd ProName</li>
</ul></li>
<li>创建爬虫文件：
<ul>
<li>scrapy genspider spiderName www.xxx.com</li>
</ul></li>
<li>编写相关操作代码</li>
<li>执行工程：
<ul>
<li>scrapy crawl spiderName</li>
</ul></li>
</ul>
<h3 id="功能">功能</h3>
<h4 id="基于管道的持久化存储">基于管道的持久化存储</h4>
<ul>
<li>修改item文件</li>
<li>修改pipelines文件</li>
<li>修改配置文件</li>
</ul>
<h4 id="便捷的全站爬取">便捷的全站爬取</h4>
<h4 id="支持分布式集群">支持分布式集群</h4>
<h3 id="实例-4">实例</h3>
<ul>
<li><p>例1 爬取糗百（持久化）</p></li>
<li><p>例2 爬取boss直聘（中间件）</p></li>
<li><p>例3 爬取图片</p></li>
<li><p>例4 爬取网易（手动全站）</p></li>
<li><p>例5 爬取阳光政务（自动全站）</p></li>
</ul>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Java访问权限之Protected</title>
    <url>/2020/12/20/JavaProtected%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h1 id="java访问权限之protected">Java访问权限之Protected</h1>
<h2 id="有的没的">有的没的</h2>
<p>示例来自于<a href="https://blog.csdn.net/justloveyou_/article/details/61672133" target="_blank" rel="noopener">Java 访问权限控制_CSDN</a>，然后个人感觉原文很详细但是解释的不太自洽，自行解释了一下。</p>
<h2 id="可见性规则">可见性规则</h2>
<ul>
<li>基类的protected成员是包内可见的，并且对子类可见；
<ul>
<li>（自己实现的类，仅包内以及子类可见）</li>
</ul></li>
<li>若子类与基类不在同一包中，那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。
<ul>
<li>（不同包时继承得到的方法只能由自己和自己的父类可见）</li>
<li>（不同包时继承得到的方法，自己只能看见自己的方法）</li>
</ul></li>
</ul>
<h2 id="示例分析">示例分析</h2>
<h3 id="示例一">示例一</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例一</span></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;    <span class="comment">// 父类Father1中的protected方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son1</span> <span class="keyword">extends</span> <span class="title">Father1</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p11;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son11</span> <span class="keyword">extends</span> <span class="title">Father1</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p1;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son1 son1 = <span class="keyword">new</span> Son1();</span><br><span class="line">        son1.f(); <span class="comment">// Compile OK     ----（1）</span></span><br><span class="line">        son1.clone(); <span class="comment">// Compile Error     ----（2）</span></span><br><span class="line"></span><br><span class="line">        Son11 son = <span class="keyword">new</span> Son11();    </span><br><span class="line">        son11.f(); <span class="comment">// Compile OK     ----（3）</span></span><br><span class="line">        son11.clone(); <span class="comment">// Compile Error     ----（4）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)(3)：f()从父类Father1处继承，Test1与Father1同包→Compile OK</p>
<p>(2)(4)：clone()从Object类（间接）继承而来，Son1的clone()只有自己以及自己的父类(Father1)可见，Test1不可见→Compile Error</p>
<h3 id="示例二">示例二</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例二</span></span><br><span class="line"><span class="keyword">package</span> p2;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p22;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> <span class="keyword">extends</span> <span class="title">MyObject2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       MyObject2 obj = <span class="keyword">new</span> MyObject2();</span><br><span class="line">       obj.clone(); <span class="comment">// Compile Error         ----（1）</span></span><br><span class="line"></span><br><span class="line">       Test2 tobj = <span class="keyword">new</span> Test2();</span><br><span class="line">       tobj.clone(); <span class="comment">// Complie OK         ----（2）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()由MyObject2 自己实现，自己以及子类(Test2)可见→Compile Error</p>
<p>(2)：clone()从父类MyObject2继承， 只有自己以及自己的父类(MyObject2)可见→Compile OK</p>
<h3 id="示例三">示例三</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例三</span></span><br><span class="line"><span class="keyword">package</span> p3;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject3</span> <span class="keyword">extends</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p33;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyObject3 obj = <span class="keyword">new</span> MyObject3();</span><br><span class="line">    obj.clone();   <span class="comment">// Compile OK     ------（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()从Object类（间接）继承而来，只有自己以及自己的父类(Test3)可见→Compile OK</p>
<h3 id="示例四">示例四</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例四</span></span><br><span class="line"><span class="keyword">package</span> p4;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject4</span> <span class="keyword">extends</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> p44;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    MyObject4 obj = <span class="keyword">new</span> MyObject4();</span><br><span class="line">    obj.clone(); <span class="comment">// Compile Error      -----（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()由MyObject4自己实现，只有自己、包内以及自己子类可见，Test4是它的父类→Compile Error</p>
<h3 id="示例五">示例五</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例五</span></span><br><span class="line"><span class="keyword">package</span> p5;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">       MyObject5 obj = <span class="keyword">new</span> MyObject5();</span><br><span class="line">       obj.clone(); <span class="comment">// Compile OK        ----(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()由MyObject4自己实现，只有自己、包内以及自己子类可见，Test5属于p5→Compile OK</p>
<h3 id="实例六">实例六</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例六</span></span><br><span class="line"><span class="keyword">package</span> p6;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject6</span> <span class="keyword">extends</span> <span class="title">Test6</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyObject6 obj = <span class="keyword">new</span> MyObject6();</span><br><span class="line">    obj.clone();        <span class="comment">// Compile OK   -------（1）</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()从Object（间接）继承而来，只有自己以及自己的父类(Test6)可见→Compile OK</p>
<h3 id="示例七">示例七</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//示例七</span></span><br><span class="line"><span class="keyword">package</span> p7;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyObject7</span> <span class="keyword">extends</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test7 test = <span class="keyword">new</span> Test7();</span><br><span class="line">        test.clone(); <span class="comment">// Compile Error   ----- (1)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(1)：clone()从Object继承而来，只有自己以及自己的父类可见→Compile Error</p>
]]></content>
      <categories>
        <category>踩坑记录</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/2021/01/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 <strong>合并</strong> 及 <strong>查询</strong> 问题。 它支持两种操作：</p>
<ul>
<li>查找（Find）：确定某个元素处于哪个子集；</li>
<li>合并（Union）：将两个子集合并成一个集合。</li>
</ul>
<h1 id="结构">结构</h1>
<p>在理解上并查集是一个森林，但是在实际实现上位了方便将其简化成数组。</p>
<h2 id="理解上的结构">理解上的结构</h2>
<h3 id="结构-1">结构</h3>
<p>每棵树代表一个子集，根节点用来标记这个子集</p>
<h3 id="操作">操作</h3>
<ul>
<li>find：递归查找父节点，最终得到标记子集的根节点（祖先）</li>
<li>union：将两棵树合并（不必在意细节，因为实现时使用数组）</li>
</ul>
<p><img src="/2021/01/13/并查/1.png" /></p>
<h2 id="实际的实现">实际的实现</h2>
<h3 id="结构-2">结构</h3>
<p>我们使用一个parent数组来存储对应索引的父亲的索引</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化代码,一开始每个节点一个子集，自己的父亲为自己</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="操作-1">操作</h3>
<ul>
<li>find操作，递归查找父节点，最终得到标记子集的根节点（祖先）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 寻找x的祖先</span></span><br><span class="line">  <span class="keyword">if</span> (parent[x] == x) &#123; <span class="comment">// 如果x是祖先则返回</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> find(parent[x]); <span class="comment">// 如果不是则x的爸爸问x的爷爷</span></span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>union操作，合并子集</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使两个集合拥有相同的祖先</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	parent[find(x)]=find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="优化">优化</h1>
<h2 id="路径压缩">路径压缩</h2>
<h3 id="概念-1">概念</h3>
<p>把每个节点都直接连接到根上 ，这就是路径压缩（把递归查找祖先的路径压缩）</p>
<p><img src="/2021/01/13/并查/2.png" /></p>
<h3 id="实现">实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">		parent[x] = find(parent[x]); <span class="comment">//把寻找祖先路上经过的节点都压缩</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="启发式合并按秩合并">启发式合并（按秩合并）</h2>
<h3 id="概念-2">概念</h3>
<p>简单来说在合并时将深度（或者节点个数）较小的合并子集到较大的子集中去</p>
<p>需要一个rank数组来粗略的记录深度（主要是为了方便，没必要精确记录深度）</p>
<h3 id="实现-1">实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化rank数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">	<span class="keyword">this</span>.rank[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">    <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">    <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rank[rootX] == rank[rootY]) &#123;</span><br><span class="line">        parent[rootX] = rootY;</span><br><span class="line">        <span class="comment">// 此时以 rootY 为根结点的树的高度仅加了 1</span></span><br><span class="line">        rank[rootY]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">        parent[rootX] = rootY;</span><br><span class="line">        <span class="comment">// 此时以 rootY 为根结点的树的高度不变</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 同理，此时以 rootX 为根结点的树的高度不变</span></span><br><span class="line">        parent[rootY] = rootX;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="总体实现">总体实现</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以 i 为根结点的子树的高度（引入了路径压缩以后该定义并不准确）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] rank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">this</span>.rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent[i] = i;</span><br><span class="line">            <span class="keyword">this</span>.rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = find(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = find(y);</span><br><span class="line">        <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rank[rootX] == rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            <span class="comment">// 此时以 rootY 为根结点的树的高度仅加了 1</span></span><br><span class="line">            rank[rootY]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rank[rootX] &lt; rank[rootY]) &#123;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            <span class="comment">// 此时以 rootY 为根结点的树的高度不变</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 同理，此时以 rootX 为根结点的树的高度不变</span></span><br><span class="line">            parent[rootY] = rootX;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x != parent[x]) &#123;</span><br><span class="line">            parent[x] = find(parent[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复杂度">复杂度</h1>
<p><a href="https://oi-wiki.org/ds/dsu/" target="_blank" rel="noopener">oi-wiki-并查集</a></p>
<h1 id="references">References</h1>
<p><a href="https://oi-wiki.org/ds/dsu/" target="_blank" rel="noopener">oi-wiki-并查集</a><br />
<a href="https://leetcode-cn.com/problems/smallest-string-with-swaps/solution/1202-jiao-huan-zi-fu-chuan-zhong-de-yuan-wgab/" target="_blank" rel="noopener">leetcode-1202题解</a></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel学习笔记:sentinel-core</title>
    <url>/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-core/</url>
    <content><![CDATA[<h1 id="有的没的">有的没的</h1>
<p>有蛮长时间没更新了，笔记一直有在做，不过暂时都放在本地了，因为有些还不太完整（选定的每篇范围太大也是一个原因）。加上最近在实习，大部分笔记放在内部的笔记软件中。不过因为Sentinel有很大一部分是开源的，所以将笔记中有关开源的分析部分重新整理出来公开了，这段时间应该陆续会有笔记被放到这边。 文中没标注的部分资料（图片）来源于文末参考链接。</p>
<h1 id="经典限流算法">经典限流算法</h1>
<h2 id="计数器算法">计数器算法</h2>
<p>Sentinel 中默认实现的 QPS 限流算法和 THREADS 限流算法都属于计数器算法。QPS 限流的默认算法是通过判断当前时间窗口（1 秒）的 pass（被放行的请求数量）指标数据判断，如果 pass 总数已经大于等于限流的 QPS 阈值，则直接拒绝当前请求，每通过一个请求当前时间窗口的 pass 指标计数加 1。THREADS 限流的实现是通过判断当前资源并行占用的线程数是否已经达到阈值，是则直接拒绝当前请求，每通过一个请求 THREADS 计数加 1，每完成一个请求 THREADS 计数减 1。</p>
<h2 id="漏桶算法leaky-bucket">漏桶算法（Leaky Bucket）</h2>
<p>漏桶就像在一个桶的底部开一个洞，不控制水放入桶的速度，而通过底部漏洞的大小控制水流失的速度，当水放入桶的速率小于或等于水通过底部漏洞流出的速率时，桶中没有剩余的水，而当水放入桶的速率大于漏洞流出的速率时，水就会逐渐在桶中积累，当桶装满水时，若再向桶中放入水，则放入的水就会溢出。我们把水换成请求，往桶里放入请求的速率就是接收请求的速率，而水流失就是请求通过，水溢出就是请求被拒绝。</p>
<h2 id="令牌桶算法token-bucket">令牌桶算法（Token Bucket）</h2>
<p>令牌桶不存放请求，而是存放为请求生成的令牌（Token），只有拿到令牌的请求才能通过。原理就是以固定速率往桶里放入令牌，每当有请求过来时，都尝试从桶中获取令牌，如果能拿到令牌请求就能通过。当桶放满令牌时，多余的令牌就会被丢弃，而当桶中的令牌被用完时，请求拿不到令牌就无法通过。</p>
<h1 id="数据模型">数据模型</h1>
<h2 id="核心类">核心类</h2>
<h3 id="arraymetric">ArrayMetric</h3>
<p>Metric的实现类，数据节点的addRtAndSuccess最后会落到该类上，该类也是sentinel记录数据模型的最外层包装</p>
<p>内部持有一个<code>LeapArray&lt;MetricBucket&gt; data</code>数据结构作为对窗口的包装，所有操作都会落到该数据结构上</p>
<p>构造方法通过传入参数的差异，为data赋值不同子类的引用（秒级窗口OccupiableBucketLeapArray，分钟级窗口BucketLeapArray）</p>
<h3 id="leaparray">LeapArray</h3>
<p>内部持有一个<code>AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt;</code>的数据结构作为实际容纳窗口的容器，各种操作会在该类中获取对应的<code>WindowWrap&lt;T&gt;</code>再进行相关操作</p>
<p><strong>成员变量</strong></p>
<p>protected int windowLengthInMs;</p>
<p>每个窗口长度（Ms）</p>
<p>protected int sampleCount;</p>
<p>滑动窗口内样本个数</p>
<p>protected int intervalInMs;</p>
<p>LeapArray总时间（Ms）</p>
<p>private double intervalInSecond;</p>
<p>LeapArray总时间（s）</p>
<p>protected final AtomicReferenceArray&lt;WindowWrap<T>&gt; array;</p>
<p>private final ReentrantLock updateLock = new ReentrantLock();</p>
<p>更新<code>WindowWrap&lt;T&gt;</code>的锁</p>
<h3 id="windowwrap">WindowWrap</h3>
<p>窗口包装类，主要用于包装MetricBucket，记录窗口元信息</p>
<p><strong>成员变量</strong></p>
<p>private final long windowLengthInMs;</p>
<p>窗口长度</p>
<p>private long windowStart;</p>
<p>窗口开始时间</p>
<p>private T value;</p>
<p>被包装的类</p>
<h3 id="metricbucket">MetricBucket</h3>
<p>实际数据存放类</p>
<p>维护了一个LongAdder数组counters，用于记录各种数据，包括以下几种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MetricEvent &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Normal pass.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PASS,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Normal block.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCK,</span><br><span class="line">    EXCEPTION,</span><br><span class="line">    SUCCESS,</span><br><span class="line">    RT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Passed in future quota (pre-occupied, since 1.5.0).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OCCUPIED_PASS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="核心方法">核心方法</h2>
<h3 id="获取数据以success为例">获取数据（以success为例）</h3>
<p>com.alibaba.csp.sentinel.slots.statistic.metric.ArrayMetric#success</p>
<p>获取窗口内的success个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法本身是用来获取当前时间所在窗口，在这边被用于更新当前时间所在窗口</span></span><br><span class="line">    data.currentWindow();</span><br><span class="line">    <span class="keyword">long</span> success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取整个窗口内的所有MetricBucket</span></span><br><span class="line">    List&lt;MetricBucket&gt; list = data.values();</span><br><span class="line">    <span class="keyword">for</span> (MetricBucket window : list) &#123;</span><br><span class="line">        <span class="comment">//累加计算总和</span></span><br><span class="line">        success += window.success();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>com.alibaba.csp.sentinel.slots.statistic.base.LeapArray#currentWindow(long)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = calculateTimeIdx(timeMillis);</span><br><span class="line">        <span class="comment">// Calculate current bucket start time.</span></span><br><span class="line">        <span class="keyword">long</span> windowStart = calculateWindowStart(timeMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Get bucket item at given time from the array.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * (1) Bucket is absent, then just create a new bucket and CAS update to circular array.</span></span><br><span class="line"><span class="comment">         * (2) Bucket is up-to-date, then just return the bucket.</span></span><br><span class="line"><span class="comment">         * (3) Bucket is deprecated, then reset current bucket and clean all deprecated buckets.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            WindowWrap&lt;T&gt; old = array.get(idx);</span><br><span class="line">            <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *     B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">                 * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">                 * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">                 *                             ^</span></span><br><span class="line"><span class="comment">                 *                          time=888</span></span><br><span class="line"><span class="comment">                 *            bucket is empty, so create new and update</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * If the old bucket is absent, then we create a new bucket at &#123;@code windowStart&#125;,</span></span><br><span class="line"><span class="comment">                 * then try to update circular array via a CAS operation. Only one thread can</span></span><br><span class="line"><span class="comment">                 * succeed to update, while other threads yield its time slice.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">                <span class="keyword">if</span> (array.compareAndSet(idx, <span class="keyword">null</span>, window)) &#123;</span><br><span class="line">                    <span class="comment">// Successfully updated, return the created bucket.</span></span><br><span class="line">                    <span class="keyword">return</span> window;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *     B0       B1      B2     B3      B4</span></span><br><span class="line"><span class="comment">                 * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">                 * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">                 *                             ^</span></span><br><span class="line"><span class="comment">                 *                          time=888</span></span><br><span class="line"><span class="comment">                 *            startTime of Bucket 3: 800, so it's up-to-date</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * If current &#123;@code windowStart&#125; is equal to the start timestamp of old bucket,</span></span><br><span class="line"><span class="comment">                 * that means the time is within the bucket, so directly return the bucket.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *   (old)</span></span><br><span class="line"><span class="comment">                 *             B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">                 * |_______||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">                 * ...    1200     1400    1600    1800    2000    2200  timestamp</span></span><br><span class="line"><span class="comment">                 *                              ^</span></span><br><span class="line"><span class="comment">                 *                           time=1676</span></span><br><span class="line"><span class="comment">                 *          startTime of Bucket 2: 400, deprecated, should be reset</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * If the start timestamp of old bucket is behind provided time, that means</span></span><br><span class="line"><span class="comment">                 * the bucket is deprecated. We have to reset the bucket to current &#123;@code windowStart&#125;.</span></span><br><span class="line"><span class="comment">                 * Note that the reset and clean-up operations are hard to be atomic,</span></span><br><span class="line"><span class="comment">                 * so we need a update lock to guarantee the correctness of bucket update.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * The update lock is conditional (tiny scope) and will take effect only when</span></span><br><span class="line"><span class="comment">                 * bucket is deprecated, so in most cases it won't lead to performance loss.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// Successfully get the update lock, now we reset the bucket.</span></span><br><span class="line">                        <span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        updateLock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123;</span><br><span class="line">                <span class="comment">// Should not go through here, as the provided time is already behind.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注释非常详细，需要注意的是resetWindowTo方法，不同子类有不同的实现</p>
<ul>
<li>BucketLeapArray：重置窗口开始时间，将各种数据置为0</li>
<li>OccupiableBucketLeapArray：重置窗口开始时间，将borrowArray中对应时间的MetricBucket的数据作为窗口的数据，而不是直接归零（具体作用在流控中解释）</li>
</ul>
<p>com.alibaba.csp.sentinel.slots.statistic.base.LeapArray#values()</p>
<p>com.alibaba.csp.sentinel.slots.statistic.base.LeapArray#values(long)</p>
<p>获取窗口内的所有有效的（非过期）MetricBucket，组成list返回</p>
<h3 id="增加数据以addsuccess为例">增加数据（以addSuccess为例）</h3>
<p>com.alibaba.csp.sentinel.slots.statistic.metric.ArrayMetric#addSuccess</p>
<p>调用currentWindow获取当前窗口后调用value()获取MetricBucket再调用addSuccess(count)方法</p>
<h2 id="滑动窗口类型">滑动窗口类型</h2>
<h3 id="分钟级滑动窗口">分钟级滑动窗口</h3>
<p>窗口总长度60秒，每个样本窗口1秒，总共60个样本窗口</p>
<p>private transient Metric rollingCounterInMinute = new ArrayMetric(60, 60 * 1000, false);</p>
<h3 id="秒级滑动窗口">秒级滑动窗口</h3>
<p>窗口总长度1秒，每个样本窗口500ms，总共2个样本窗口</p>
<p>private transient volatile Metric rollingCounterInSecond =<br />
new ArrayMetric(SampleCountProperty.<em>SAMPLE_COUNT</em>,IntervalProperty.<em>INTERVAL</em>);</p>
<p>PS：秒级窗口不精确，监控中的秒级数据来自于分钟级窗口，只有需要最近1秒的数据时才会使用秒级滑动窗口的值（详情可以看文首第二个链接）</p>
<h1 id="切入流程">切入流程</h1>
<p>（以SpringBoot版本为例）</p>
<h2 id="通过aop机制织入">通过AOP机制织入</h2>
<p>com.alibaba.csp.sentinel.annotation.aspectj.SentinelResourceAspect</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelResourceAspect</span> <span class="keyword">extends</span> <span class="title">AbstractSentinelAspectSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.alibaba.csp.sentinel.annotation.SentinelResource)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sentinelResourceAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"sentinelResourceAnnotationPointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeResourceWithSentinel</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取方法</span></span><br><span class="line">        Method originMethod = resolveMethod(pjp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取注解</span></span><br><span class="line">        SentinelResource annotation = originMethod.getAnnotation(SentinelResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Should not go through here.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wrong state for SentinelResource annotation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取资源名称</span></span><br><span class="line">        String resourceName = getResourceName(annotation.value(), originMethod);</span><br><span class="line">        <span class="comment">//获取类型（OUT or IN）</span></span><br><span class="line">        EntryType entryType = annotation.entryType();</span><br><span class="line">        Entry entry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//核心部分，入口</span></span><br><span class="line">            entry = SphU.entry(resourceName, entryType, <span class="number">1</span>, pjp.getArgs());</span><br><span class="line">            <span class="comment">//通过，允许调用</span></span><br><span class="line">            Object result = pjp.proceed();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">            <span class="comment">//不通过，不允许调用</span></span><br><span class="line">            <span class="keyword">return</span> handleBlockException(pjp, annotation, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Tracer.trace(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//退出入口</span></span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="entry">Entry</h2>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image2.png" alt="" /><figcaption>LearningGp</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">entryWithPriority</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取ThreadLocal中已经存在的context</span></span><br><span class="line">    Context context = ContextUtil.getContext();</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> NullContext) &#123;</span><br><span class="line">        <span class="comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span></span><br><span class="line">        <span class="comment">// so here init the entry only. No rule checking will be done.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Using default context.</span></span><br><span class="line">        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global switch is close, no rule checking will do.</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.ON) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过SPI机制加载处理链</span></span><br><span class="line">    ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;,</span></span><br><span class="line"><span class="comment">         * so no rule checking will be done.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造Entry实例</span></span><br><span class="line">    Entry e = <span class="keyword">new</span> CtEntry(resourceWrapper, chain, context);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        /进入处理链</span><br><span class="line">        chain.entry(context, resourceWrapper, <span class="keyword">null</span>, count, prioritized, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">        e.exit(count, args);</span><br><span class="line">        <span class="keyword">throw</span> e1;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">        <span class="comment">// This should not happen, unless there are errors existing in Sentinel internal.</span></span><br><span class="line">        RecordLog.info(<span class="string">"Sentinel unexpected exception"</span>, e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在处理链指针不为空的情况下按序调用进入方法并返回</p>
<h1 id="核心类-1">核心类</h1>
<h2 id="context">Context</h2>
<p>Context 代表调用链路上下文，贯穿一次调用链路中的所有 Entry。Context 维持着入口节点（entranceNode）、本次调用链路的 curNode、调用来源（origin）等信息。Context 名称即为调用链路入口名称。</p>
<p>Context 通过 ThreadLocal 传递，只在调用链路的入口处创建。</p>
<p>Context 的字段说明：</p>
<ul>
<li>name：Context 的名称。</li>
<li>entranceNode：当前调用树的入口节点，类型为 EntranceNode。同一个入口的资源，每个资源对应一个 DefaultNode，entranceNode#childList 用于存储这些资源的 DefaultNode。</li>
<li>curEntry：当前 Entry（CtEntry）。</li>
<li>origin：调用来源的名称，即服务消费者的名称或者服务消费者的来源 IP，取决于服务消费者是否使用 Sentinel，由 Sentinel 适配层传递过来。例如：服务提供者是 Spring MVC 应用，且服务提供者使用 Sentinel 的 Web MVC 适配，那么 Sentinel 会尝试从请求头获取"S-user"，如果服务消费者有在请求头传递这个参数，那么就能够获取到</li>
</ul>
<h2 id="entry-1">Entry</h2>
<p>在调用 Context#getCurNode 方法获取调用链路上当前访问到的资源的 DefaultNode 时，实际是从 Context#curEntry 获取的，Entry 维护了当前资源的 DefaultNode，以及调用来源的 StatisticNode。</p>
<p>CtEntry 是 Entry 的直接子类</p>
<p>CtEntry 用于维护父子 Entry，每一次调用 SphU#entry 方法都会创建一个 CtEntry。如果服务 B 在处理一个请求的路径上会多次调用 SphU#entry，那么这些 CtEntry 会构成一个双向链表。在每次创建 CtEntry，都会将 Context.curEntry 设置为这个新的 CtEntry，双向链表的作用就是在调用 CtEntry#exit 方法时，能够将 Context.curEntry 还原为上一个资源的 CtEntry。</p>
<h2 id="node">Node</h2>
<p>用于持有实时统计的指标数据</p>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image1.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<p>Node实际上是数据节点，主要用于统计各种规则所需要的数据，如QPS，线程数等等。各个Node因为记录数据的不同有以下四个实现</p>
<h3 id="statisticnode">StatisticNode</h3>
<p>数据统计节点，核心数据是以下三个</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds statistics of the recent &#123;<span class="doctag">@code </span>INTERVAL&#125; seconds. The &#123;<span class="doctag">@code </span>INTERVAL&#125; is divided into time spans</span></span><br><span class="line"><span class="comment">     * by given &#123;<span class="doctag">@code </span>sampleCount&#125;.</span></span><br><span class="line"><span class="comment">     * 秒级滑动窗口，用于统计实时的 QPS，2 个时间窗口大小为 500 毫秒的 Bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private transient volatile Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(SampleCountProperty.SAMPLE_COUNT,</span><br><span class="line">                                                                           IntervalProperty.INTERVAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds statistics of the recent 60 seconds. The windowLengthInMs is deliberately set to 1000 milliseconds,</span></span><br><span class="line"><span class="comment">     * meaning each bucket per second, in this way we can get accurate statistics of each second.</span></span><br><span class="line"><span class="comment">     * 分级滑动窗口，用于保存最近一分钟内的历史指标数据，60 个 Bucket 数组，每个 Bucket 统计的时间窗口大小为 1 秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private transient Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The counter for thread count.</span></span><br><span class="line"><span class="comment">     * 并发线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private LongAdder curThreadNum = <span class="keyword">new</span> LongAdder();</span><br></pre></td></tr></table></figure>
<p>滑动窗口使用场景</p>
<ul>
<li>获取前一秒被 Sentinel 拒绝的请求总数从分钟级滑动窗口获取</li>
<li>获取当前一秒内已经被 Sentinel 拒绝的请求总数则从秒级滑动窗口获取</li>
<li>获取最小耗时也是从秒级的滑动窗口获取</li>
</ul>
<p>StatisticNode 还负责统计并行占用的线程数，用于实现信号量隔离，按资源所能并发占用的最大线程数实现限流。通过控制并发线程数实现信号量隔离的好处就是不让一个接口同时使用完线程池所有线程</p>
<p>数据统计部分采用改进的滑动窗口的方式，时间窗口+Bucket，通过循环复用 Bucket 以减少 Bucket 的创建和销毁。在统计指标数据时，利用当前时间戳定位 Bucket，使用 LongAdder 统计时间窗口内的请求成功数、失败数、总耗时等指标数据优化了并发锁。Sentinel 通过定时任务递增时间戳以获取当前时间戳，避免了每次获取时间戳都使用 System 获取的性能消耗。//todo</p>
<h3 id="defaultnode">DefaultNode</h3>
<p>resource * context纬度数据统计节点，存在每个 NodeSelectorSlot 的map里</p>
<p>DefaultNode 字段说明：</p>
<ul>
<li>id：资源 ID，ResourceWrapper 对象。</li>
<li>childList：childList 是一个 Node（DefaultNode）集合，用于存放子节点。</li>
<li>clusterNode：clusterNode 字段是一个 ClusterNode，ClusterNode 也是 StatisticNode 的子类。</li>
</ul>
<h3 id="entrancenode">EntranceNode</h3>
<p>入口节点，名称相同的 Context 都使用同一个 EntranceNode</p>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image3.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h3 id="clusternode">ClusterNode</h3>
<p>统计每个资源全局的指标数据，以及统计该资源按调用来源区分的指标数据。全局数据指的是不区分调用链路，一个资源 ID 只对应一个 ClusterNode。</p>
<p>ClusterNode 字段说明：</p>
<ul>
<li>name：资源名称</li>
<li>resourceType：资源类型</li>
<li>originCountMap：维护每个调用来源的指标数据统计数据（StatisticNode）</li>
</ul>
<h2 id="root与调用树">Root与调用树</h2>
<p>Constants 常量类用于声明全局静态常量，Constants 有一个 ROOT 静态字段，类型为 EntranceNode。</p>
<p>在调用 ContextUtil#enter 方法时，如果还没有为当前入口创建 EntranceNode，则会为当前入口创建 EntranceNode，将其赋值给 Context.entranceNode，同时也会将这个 EntranceNode 添加到 Constants.ROOT 的子节点（childList）。资源对应的 DefaultNode 则是在 NodeSelectorSlot 中创建，并赋值给 Context.curEntry.curNode。</p>
<p>Constants.ROOT、Context.entranceNode 与 Entry.curNode 三者关系如下图所示。</p>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/imag6e.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h2 id="slot">Slot</h2>
<p>处理链上的插槽，核心逻辑所在</p>
<p>整体处理基于责任链模式，通过spi机制按顺序加载处理链，所有ProcessorSlot都继承AbstractLinkedProcessorSlot 类，从而组成单向链表，调用 fireEntry 方法逐个前进或者 fireExit 方法逐个后退</p>
<p>主要分成两类，一类数据统计（NodeSelectorSlot-&gt;ClusterBuilderSlot-&gt;StatisticSlot（logslot辅助用，暂时放在这类）），一类实现降级以及block</p>
<h3 id="数据统计slot">数据统计Slot</h3>
<h4 id="nodeselectorslot">NodeSelectorSlot</h4>
<p>这个 slot 主要负责收集资源的路径，并将这些资源的调用路径以树状结构存储起来，用于根据调用路径进行流量控制。</p>
<ul>
<li>为当前资源创建 DefaultNode，并且将 DefaultNode 赋值给 Context.curEntry.curNode</li>
<li>如果当前调用链路上只出现过一次 SphU#entry 的情况，将该 DefaultNode 添加到的 Context.entranceNode 的子节点，否则添加到 Context.curEntry.parent 的子节点（通过com.alibaba.csp.sentinel.context.Context#getLastNode实现）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">firstLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"firstLevel"</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">"firstLevel"</span>);</span><br><span class="line">        secondLevel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"firstLevel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">secondLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"secondLevel"</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">"secondLevel"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"secondLevel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时调用firstLevel方法会形成如下调用树</span></span><br><span class="line"></span><br><span class="line">                        ROOT (machine-root)</span><br><span class="line">                                /</span><br><span class="line">                    EntranceNode (context name: level-test)</span><br><span class="line">                           /                             </span><br><span class="line">        DefaultNode （resource name:firstLevel）    </span><br><span class="line">                    /                             </span><br><span class="line">DefaultNode （resource name:firstLevel）</span><br></pre></td></tr></table></figure>
<h4 id="clusterbuilderslot">ClusterBuilderSlot</h4>
<p>这一环的主要作用是构建 ClusterNode，为资源纬度的统计节点</p>
<ul>
<li>如果当前资源未创建 ClusterNode，则为资源创建 ClusterNode；</li>
<li>将 ClusterNode 赋值给当前资源的 DefaultNode.clusterNode；</li>
<li>如果调用来源（origin）不为空，则为调用来源创建 StatisticNode，用于实现按调用来源统计资源的指标数据，ClusterNode 持有每个调用来源的 StatisticNode。</li>
</ul>
<p>ps：ClusterBuilderSlot持有非静态<code>private volatile ClusterNode clusterNode = null;</code>，因为一个资源只会创建一个 ProcessorSlotChain，意味着 ClusterBuilderSlot 也只会创建一个，那么让 ClusterBuilderSlot 持有该资源的 ClusterNode 就可以省去每次都从 Map 中获取的步骤</p>
<h4 id="logslot">LogSlot</h4>
<p>进入时直接fire，在后续节点抛出BlockException后在这里将相关日志记录</p>
<h4 id="statisticslot">StatisticSlot</h4>
<p>负责进行数据统计，也是先fire，在后续节点处理完之后，在这里对统计的数据进行记录</p>
<h5 id="entry-方法">entry 方法</h5>
<h6 id="请求正常通过">请求正常通过</h6>
<ul>
<li>当前资源并行占用的线程数增加 1、当前时间窗口被放行的请求总数加 1</li>
<li>如果调用来源不为空，也将调用来源的 StatisticNode 的当前并行占用线程数加 1、当前时间窗口被放行的请求数加 1</li>
<li>如果流量类型为 IN，则将资源全局唯一的 ClusterNode 的并行占用线程数、当前时间窗口被放行的请求数都增加 1</li>
<li>回调所有 ProcessorSlotEntryCallback#onPass 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node.increaseThreadNum();</span><br><span class="line">node.addPassRequest(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Add count for origin node.</span></span><br><span class="line">    context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class="line">    context.getCurEntry().getOriginNode().addPassRequest(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">    <span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">    Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class="line">    Constants.ENTRY_NODE.addPassRequest(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle pass event with registered entry callback handlers.</span></span><br><span class="line"><span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">    handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="捕获prioritywaitexception异常">捕获PriorityWaitException异常</h6>
<p>（特殊情况）</p>
<p>当捕获到 PriorityWaitException 异常时，说明当前请求已经被休眠了一会了，但请求还是允许通过的</p>
<ul>
<li>不需要为 DefaultNode 记录这个请求的指标数据</li>
<li>自增当前资源并行占用的线程数</li>
<li>为 ClusterNode 自增并行占用的线程数</li>
<li>回调所有 ProcessorSlotEntryCallback#onPass 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">node.increaseThreadNum();</span><br><span class="line"><span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Add count for origin node.</span></span><br><span class="line">    context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">    <span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">    Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Handle pass event with registered entry callback handlers.</span></span><br><span class="line"><span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">    handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="捕获到-blockexception-异常">捕获到 BlockException 异常</h6>
<ul>
<li>将异常记录到调用链路上下文的当前 Entry（StatisticSlot 的 exit 方法会用到）</li>
<li>调用 DefaultNode#increaseBlockQps 方法记录当前请求被拒绝</li>
<li>将当前时间窗口的 block qps 这项指标数据的值加 1</li>
<li>如果调用来源不为空，让调用来源的 StatisticsNode 也记录当前请求被拒绝</li>
<li>如果流量类型为 IN，则让用于统计所有资源指标数据的 ClusterNode 也记录当前请求被拒绝</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Blocked, set block exception to current entry.</span></span><br><span class="line">context.getCurEntry().setBlockError(e);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add block count.</span></span><br><span class="line">node.increaseBlockQps(count);</span><br><span class="line"><span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    context.getCurEntry().getOriginNode().increaseBlockQps(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">    <span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">    Constants.ENTRY_NODE.increaseBlockQps(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle block event with registered entry callback handlers.</span></span><br><span class="line"><span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">    handler.onBlocked(e, context, resourceWrapper, node, count, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
<h6 id="捕获到其他异常">捕获到其他异常</h6>
<ul>
<li>让 DefaultNode 记录当前请求异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unexpected internal error, set error to current entry.</span></span><br><span class="line">context.getCurEntry().setError(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
<h5 id="exit-方法">exit 方法</h5>
<p>由于StatisticSlot 在捕获异常时将异常记录到当前 Entry，exit 方法中通过 Context 可获取到当前 CtEntry，从当前 CtEntry 可获取 entry 方法中写入的异常，从而得知请求的具体状况，完成相应操作</p>
<ul>
<li>计算耗时</li>
<li>记录执行耗时与成功总数</li>
<li>自减当前资源占用线程数</li>
<li>来源不为空，减少来源的线程数</li>
<li>流量为In，让用于统计所有资源指标数据的 ClusterNode 也记录相关信息</li>
<li>调用回调方法</li>
</ul>
<p>PS:在 DefaultNode 的相关指标数据收集方法被调用时，ClusterNode 的对应方法也会被调用</p>
<h3 id="限流降级以及流控slot">限流降级以及流控Slot</h3>
<h4 id="authorityslot">AuthoritySlot</h4>
<p>权限控制，根据 <strong>origin</strong> 做黑白名单的控制</p>
<h4 id="systemslot">SystemSlot</h4>
<p>实现自适应限流（针对全局入口流量）<br />
com.alibaba.csp.sentinel.slots.system.SystemRuleManager#checkSystem</p>
<p>主要比较参数有successQps，curThreadNum，avgRt，<em>highestSystemLoad，highestCpuUsage</em></p>
<p>通过起一个后台线程（SystemMetricCollectorTask），每秒查询一次系统负载和CPU使用负载</p>
<p>第一版基于TCP BBR算法（结合自动化控制理论优化中PID controller）</p>
<p>第二版将系统指标（load/CPU usage）作为一个启动条件</p>
<p>com.alibaba.csp.sentinel.slots.system.SystemRuleManager#checkSystem</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSystem</span><span class="params">(ResourceWrapper resourceWrapper)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resourceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure the checking switch is on.</span></span><br><span class="line">    <span class="keyword">if</span> (!checkSystemStatus.get()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for inbound traffic only</span></span><br><span class="line">    <span class="keyword">if</span> (resourceWrapper.getEntryType() != EntryType.IN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total qps</span></span><br><span class="line">    <span class="keyword">double</span> currentQps = Constants.ENTRY_NODE == <span class="keyword">null</span> ? <span class="number">0.0</span> : Constants.ENTRY_NODE.successQps();</span><br><span class="line">    <span class="keyword">if</span> (currentQps &gt; qps) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"qps"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total thread</span></span><br><span class="line">    <span class="keyword">int</span> currentThread = Constants.ENTRY_NODE == <span class="keyword">null</span> ? <span class="number">0</span> : Constants.ENTRY_NODE.curThreadNum();</span><br><span class="line">    <span class="keyword">if</span> (currentThread &gt; maxThread) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> rt = Constants.ENTRY_NODE == <span class="keyword">null</span> ? <span class="number">0</span> : Constants.ENTRY_NODE.avgRt();</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; maxRt) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"rt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load. BBR algorithm.</span></span><br><span class="line">    <span class="keyword">if</span> (highestSystemLoadIsSet &amp;&amp; getCurrentSystemAvgLoad() &gt; highestSystemLoad) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkBbr(currentThread)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"load"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cpu usage</span></span><br><span class="line">    <span class="keyword">if</span> (highestCpuUsageIsSet &amp;&amp; getCurrentCpuUsage() &gt; highestCpuUsage) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"cpu"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flowslot">FlowSlot</h4>
<p>负责流控功能的实现</p>
<p>由 ProcessorSlot、Checker、Rule、RuleManager 组合完成，ProcessorSlot作为入口，并持有对应的Checker，Checker根据Rule进行检查，RuleManager管理Rule</p>
<p>主要步骤如下</p>
<ol type="1">
<li>在 ProcessorSlot#entry 方法中调用 Checker#check 方法，并将 DefaultNode 传递给 Checker。</li>
<li>Checker 根据资源名称从 RuleManager 获取为该资源配置的规则。</li>
<li>Checker 从 传入context，以及node中根据rule和策略获取需要的node
<ol start="4" type="1">
<li>如果当前限流规则的 limitApp 不为 default，该限流规则只针对指定调用来源限流。当调用来源与当前限流规则的 limitApp 相等时：
<ol start="5" type="1">
<li>strategy 为 STRATEGY_DIRECT，则使用调用来源的 StatisticNode，实现针对调用来源限流。</li>
<li>strategy 为 STRATEGY_RELATE：根据限流规则配置的 refResource 获取引用资源的 ClusterNode，即使用引用资源的指标数据限流。通俗点说就是使用其它资源的指标数据限流，你的并发量高我就限流，让你多处理一点请求，等你并发量降低了，我就不限流了；</li>
<li>strategy 为 STRATEGY_CHAIN：使用当前资源的 DefauleNode，实现按调用链路的资源指标数据限流。</li>
</ol></li>
<li>当 limitApp 为 default 时，针对所有来源限流。
<ol start="9" type="1">
<li>strategy 为 STRATEGY_DIRECT，则使用当前资源的 ClusterNode。</li>
<li>strategy 为 STRATEGY_RELATE：使用引用资源的 ClusterNode；</li>
<li>strategy 为 STRATEGY_CHAIN：使用当前资源的 DefauleNode。</li>
</ol></li>
<li>如果 limitApp 为 other，且该资源的所有限流规则都没有针对当前的调用来源限流。
<ol start="12" type="1">
<li>如果 strategy 为 STRATEGY_DIRECT，则使用 origin 的 StatisticNode。</li>
</ol></li>
<li>strategy 为 STRATEGY_RELATE：使用引用资源的 ClusterNode</li>
<li>strategy 为 STRATEGY_CHAIN：使用当前资源的 DefauleNode</li>
</ol></li>
<li>根据配置调用对应的controller的canPass方法</li>
<li>从node中获取当前时间窗口的某项指标数据（QPS、avgRt 等）与规则的阈值对比，如果达到规则的阈值则抛出 Block 异常。</li>
</ol>
<h5 id="trafficshapingcontroller">TrafficShapingController</h5>
<p>实现流量塑形的controller主要有以下几种</p>
<h6 id="defaultcontroller">DefaultController</h6>
<p>实现快速失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前规则的限流阈值类型为 QPS，则返回node当前时间窗口统计的QPS；</span></span><br><span class="line">    <span class="comment">//如果当前规则的限流阈值类型为 THREADS，则返回node统计的当前并行占用的线程数。</span></span><br><span class="line">    <span class="keyword">int</span> curCount = avgUsedTokens(node);</span><br><span class="line">    <span class="comment">//判断加上acquireCount是否超过阈值，超过阈值则拒绝（prioritized除外）</span></span><br><span class="line">    <span class="keyword">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class="line">        <span class="comment">//如果限流阈值类型为 QPS且为优先流量，可以占用之后的流量（并非直接执行，需要等待对应时间）</span></span><br><span class="line">        <span class="keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentTime;</span><br><span class="line">            <span class="keyword">long</span> waitInMs;</span><br><span class="line">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">            <span class="comment">//计算占用之后流量后需要等待的时间（只允许占用1秒）</span></span><br><span class="line">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class="line">            <span class="comment">//判断是否超过等待最长时间</span></span><br><span class="line">            <span class="keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">                <span class="comment">//允许占用</span></span><br><span class="line">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class="line">                node.addOccupiedPass(acquireCount);</span><br><span class="line">                sleep(waitInMs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PriorityWaitException(waitInMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOccupyNext</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">int</span> acquireCount, <span class="keyword">double</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最多可占用令牌数（1s产生的令牌）</span></span><br><span class="line">    <span class="keyword">double</span> maxCount = threshold * IntervalProperty.INTERVAL / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//当前秒级窗口已经被占用令牌数</span></span><br><span class="line">    <span class="keyword">long</span> currentBorrow = rollingCounterInSecond.waiting();</span><br><span class="line">    <span class="keyword">if</span> (currentBorrow &gt;= maxCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> OccupyTimeoutProperty.getOccupyTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//样本窗口长度</span></span><br><span class="line">    <span class="keyword">int</span> windowLength = IntervalProperty.INTERVAL / SampleCountProperty.SAMPLE_COUNT;</span><br><span class="line">    <span class="comment">//currentTime - currentTime % windowLength 当前时间所在样本窗口开始时间</span></span><br><span class="line">    <span class="comment">//当前窗口开始时间，也是要占用的第一个样本窗口的开始时间</span></span><br><span class="line">    <span class="keyword">long</span> earliestTime = currentTime - currentTime % windowLength + windowLength - IntervalProperty.INTERVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note: here &#123;@code currentPass&#125; may be less than it really is NOW, because time difference</span></span><br><span class="line"><span class="comment">         * since call rollingCounterInSecond.pass(). So in high concurrency, the following code may</span></span><br><span class="line"><span class="comment">         * lead more tokens be borrowed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="comment">//当前秒级窗口通过的请求数</span></span><br><span class="line">    <span class="keyword">long</span> currentPass = rollingCounterInSecond.pass();</span><br><span class="line">    <span class="keyword">while</span> (earliestTime &lt; currentTime) &#123;</span><br><span class="line">        <span class="comment">//计算等待时间，等待到当前窗口结束（因为一个样本窗口可以存在于多个未来窗口中，当idx为0时，当前样本窗口为当前未来窗口的最后一个样本窗口，为1时当前样本窗口为当前未来窗口的倒数第二个样本窗口）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *｜--1--｜--2--｜--3--｜</span></span><br><span class="line"><span class="comment">         *idx=0 当前样本窗口为3，等待到结束</span></span><br><span class="line"><span class="comment">         *idx=1 当前样本窗口为2，同样等待到结束，比idx=1时多一个样本窗口时间长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> waitInMs = idx * windowLength + windowLength - currentTime % windowLength;</span><br><span class="line">        <span class="comment">//超时退出</span></span><br><span class="line">        <span class="keyword">if</span> (waitInMs &gt;= OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目前所在未来窗口的通过数</span></span><br><span class="line">        <span class="keyword">long</span> windowPass = rollingCounterInSecond.getWindowPass(earliestTime);</span><br><span class="line">        <span class="comment">//当前窗口通过数+当前窗口被占用数+需要的令牌数-目前所在未来窗口的通过数（重复计算所以减去）&lt;=最多可占用令牌数</span></span><br><span class="line">        <span class="keyword">if</span> (currentPass + currentBorrow + acquireCount - windowPass &lt;= maxCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> waitInMs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//占用窗口后移</span></span><br><span class="line">        earliestTime += windowLength;</span><br><span class="line">        currentPass -= windowPass;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OccupyTimeoutProperty.getOccupyTimeout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ratelimitercontroller">RateLimiterController</h6>
<p>实现排队等待</p>
<blockquote>
<p>设置 QPS 为 10，那么每 100 毫秒允许通过一个，通过计算当前时间是否已经过了上一个请求的通过时间 latestPassedTime 之后的 100 毫秒，来判断是否可以通过。假设才过了 50ms，那么需要当前线程再 sleep 50ms，然后才可以通过。如果同时有另一个请求呢？那需要 sleep 150ms 才行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Pass when acquire count is less or equal than 0.</span></span><br><span class="line">        <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Reject when count is less or equal than 0.</span></span><br><span class="line">        <span class="comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Calculate the interval between every two requests.</span></span><br><span class="line">        <span class="keyword">long</span> costTime = Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expected pass time of this request.</span></span><br><span class="line">        <span class="keyword">long</span> expectedTime = costTime + latestPassedTime.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">            <span class="comment">// Contention may exist here, but it's okay.</span></span><br><span class="line">            latestPassedTime.set(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Calculate the time to wait.</span></span><br><span class="line">            <span class="keyword">long</span> waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> oldTime = latestPassedTime.addAndGet(costTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                        latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// in race condition waitTime may &lt;= 0</span></span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(waitTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="warmupcontroller">WarmUpController</h6>
<p>实现Warm Up</p>
<p>Warm Up，冷启动。在应用升级重启时或长时间低压力之后，应用自身需要一个预热的过程，预热之后才能到达一个稳定的性能状态，比如说，接口预热阶段完成 JIT 即时编译、完成一些单例对象的创建、线程池的创建、各种连接池的初始化、或者执行首次需要加锁执行的代码块。核心算法借鉴了Guava中SmoothWarmingUp的实现，详细分析见<br />
<a href="https://www.javadoop.com/post/rate-limiter" target="_blank" rel="noopener">https://www.javadoop.com/post/rate-limiter</a><br />
<a href="https://www.jianshu.com/p/280bf2dbd6f0" target="_blank" rel="noopener">https://www.jianshu.com/p/280bf2dbd6f0</a>（推荐这篇）</p>
<p>在构造函数中通过double count, int warmUpPeriodInSec, int coldFactor三个参数，计算出warningToken，maxToken，slope</p>
<p>但是由于关注的qps所以对一些变量进行了替换</p>
<ul>
<li>warmupPeriod=warmUpPeriodInSec</li>
<li>stableInterval=1/count</li>
<li>maxPermits=maxToken</li>
<li>thresholdPermits=warningToken</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (coldFactor &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cold factor should be larger than 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.coldFactor = coldFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// thresholdPermits = 0.5 * warmupPeriod / stableInterval.</span></span><br><span class="line">    <span class="comment">// warningToken = 100;</span></span><br><span class="line">    warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// / maxPermits = thresholdPermits + 2 * warmupPeriod /</span></span><br><span class="line">    <span class="comment">// (stableInterval + coldInterval)</span></span><br><span class="line">    <span class="comment">// maxToken = 200</span></span><br><span class="line">    maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slope</span></span><br><span class="line">    <span class="comment">// slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits</span></span><br><span class="line">    <span class="comment">// - thresholdPermits);</span></span><br><span class="line">    slope = (coldFactor - <span class="number">1.0</span>) / count / (maxToken - warningToken);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断计算该点对应的qps阈值，进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> passQps = (<span class="keyword">long</span>) node.passQps();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> previousQps = (<span class="keyword">long</span>) node.previousPassQps();</span><br><span class="line">    <span class="comment">//设置 storedTokens 和 lastFilledTime 到正确的值，重新装填令牌桶</span></span><br><span class="line">    syncToken(previousQps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始计算它的斜率</span></span><br><span class="line">    <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">    <span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line">    <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">        <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line">        <span class="comment">// 消耗的速度要比warning快</span></span><br><span class="line">        <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">        <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncToken</span><span class="params">(<span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">    currentTime = currentTime - currentTime % <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">long</span> oldLastFillTime = lastFilledTime.get();</span><br><span class="line">    <span class="keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="comment">//计算新的令牌数量</span></span><br><span class="line">    <span class="keyword">long</span> newValue = coolDownTokens(currentTime, passQps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;</span><br><span class="line">        <span class="keyword">long</span> currentValue = storedTokens.addAndGet(<span class="number">0</span> - passQps);</span><br><span class="line">        <span class="keyword">if</span> (currentValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            storedTokens.set(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lastFilledTime.set(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">coolDownTokens</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="keyword">long</span> newValue = oldValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加令牌的判断前提条件:</span></span><br><span class="line">    <span class="comment">// 当令牌的消耗程度远远低于警戒线的时候</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue &lt; warningToken) &#123;</span><br><span class="line">        <span class="comment">//按照每秒count个的速度掉落</span></span><br><span class="line">        newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//令牌消耗速率大于警戒线</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue &gt; warningToken) &#123;</span><br><span class="line">        <span class="comment">//前一个bucket通过的qps小于阈值/ coldFactor，说明系统消耗令牌的速度，小于冷却速度，需要添加令牌</span></span><br><span class="line">        <span class="keyword">if</span> (passQps &lt; (<span class="keyword">int</span>)count / coldFactor) &#123;</span><br><span class="line">            newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(newValue, maxToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="warmupratelimitercontroller">WarmUpRateLimiterController</h6>
<p>RateLimiterController与WarmUpController的结合</p>
<p>通过WarmUpController中一样的算法计算出当前的qps阈值，再用该阈值去计算等待时间</p>
<h4 id="degradeslot">DegradeSlot</h4>
<p>实现熔断降级的切入点，功能由ProcessorSlot、CircuitBreaker、DegradeRule、DegradeRuleManager组合完成。且经过一次升级，通过状态间的自动转换避免了原版本使用定时器的缺点。</p>
<h5 id="熔断策略">熔断策略</h5>
<ul>
<li>SLOW_REQUEST_RATIO：按慢请求比率</li>
<li>ERROR_RATIO：按失败比率</li>
<li>ERROR_COUNT：按失败次数</li>
</ul>
<p>ExceptionCircuitBreaker实现根据异常比例熔断</p>
<p>ResponseTimeCircuitBreaker实现根据RT时间熔断</p>
<p>slot中通过调用两者的onRequestComplete方法统计并且判断是否熔断的逻辑</p>
<h5 id="熔断器状态">熔断器状态</h5>
<ul>
<li>当熔断器状态为半开启状态时，直接拒绝请求；</li>
<li>当熔断器为关闭状态时，请求被允许通过；</li>
<li>当熔断器状态为开启状态时，根据 timeWindow 尝试将开关状态改为半闭合，如何修改成功，则允许当前请求通过。</li>
</ul>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/ima8ge.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h5 id="详细分析">详细分析</h5>
<p>这一块的实现，内部版本与开源版本略有不同，这边的分析以开源版本为例。</p>
<p>核心方法如下</p>
<p><strong>AbstractCircuitBreaker#tryPass</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryPass</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Template implementation.</span></span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.CLOSED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.OPEN) &#123;</span><br><span class="line">        <span class="comment">// For half-open state we allow a request for probing.</span></span><br><span class="line">        <span class="comment">//熔断器开启状态，判断是否到达可以重试时间并尝试将状态改到半开启</span></span><br><span class="line">        <span class="keyword">return</span> retryTimeoutArrived() &amp;&amp; fromOpenToHalfOpen(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AbstractCircuitBreaker#状态转换</strong></p>
<p>基本都是使用CAS机制更改状态并且调用监听</p>
<p>下面展示的是解决一个bug的临时方案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">fromOpenToHalfOpen</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.compareAndSet(State.OPEN, State.HALF_OPEN)) &#123;</span><br><span class="line">        notifyObservers(State.OPEN, State.HALF_OPEN, <span class="keyword">null</span>);</span><br><span class="line">        Entry entry = context.getCurEntry();</span><br><span class="line">        entry.whenTerminate(<span class="keyword">new</span> BiConsumer&lt;Context, Entry&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Context context, Entry entry)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Note: This works as a temporary workaround for https://github.com/alibaba/Sentinel/issues/1638</span></span><br><span class="line">                <span class="comment">// Without the hook, the circuit breaker won't recover from half-open state in some circumstances</span></span><br><span class="line">                <span class="comment">// when the request is actually blocked by upcoming rules (not only degrade rules).</span></span><br><span class="line">                <span class="comment">//为了解决注释中提到的问题，在发生异常后将状态改回open，以防止永久处于half-open状态的bug</span></span><br><span class="line">                <span class="keyword">if</span> (entry.getBlockError() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Fallback to OPEN due to detecting request is blocked</span></span><br><span class="line">                    currentState.compareAndSet(State.HALF_OPEN, State.OPEN);</span><br><span class="line">                    notifyObservers(State.HALF_OPEN, State.OPEN, <span class="number">1.0</span>d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ExceptionCircuitBreaker#onRequestComplete</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestComplete</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Entry entry = context.getCurEntry();</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Throwable error = entry.getError();</span><br><span class="line">    SimpleErrorCounter counter = stat.currentWindow().value();</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//出现异常，增加异常计数器</span></span><br><span class="line">        counter.getErrorCount().add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加总计数器</span></span><br><span class="line">    counter.getTotalCount().add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    handleStateChangeWhenThresholdExceeded(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStateChangeWhenThresholdExceeded</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//熔断器打开直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.OPEN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//熔断器半开，本次请求如果无异常，关闭熔断器，否则重新打开熔断器</span></span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.HALF_OPEN) &#123;</span><br><span class="line">        <span class="comment">// In detecting request</span></span><br><span class="line">        <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fromHalfOpenToClose();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fromHalfOpenToOpen(<span class="number">1.0</span>d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//熔断器关闭状态</span></span><br><span class="line">    List&lt;SimpleErrorCounter&gt; counters = stat.values();</span><br><span class="line">    <span class="keyword">long</span> errCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> totalCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (SimpleErrorCounter counter : counters) &#123;</span><br><span class="line">        errCount += counter.errorCount.sum();</span><br><span class="line">        totalCount += counter.totalCount.sum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未达到最小请求数，返回</span></span><br><span class="line">    <span class="keyword">if</span> (totalCount &lt; minRequestAmount) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> curCount = errCount;</span><br><span class="line">    <span class="comment">//计算异常比例</span></span><br><span class="line">    <span class="keyword">if</span> (strategy == DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class="line">        <span class="comment">// Use errorRatio</span></span><br><span class="line">        curCount = errCount * <span class="number">1.0</span>d / totalCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常比例大于阈值，熔断器打开</span></span><br><span class="line">    <span class="keyword">if</span> (curCount &gt; threshold) &#123;</span><br><span class="line">        transformToOpen(curCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ResponseTimeCircuitBreaker#onRequestComplete</strong></p>
<p>整体类似上一个方法，不再赘述</p>
<h1 id="一些对应关系">一些对应关系</h1>
<p>一个context（context name为唯一标识，context跟着线程走，切换线程需要手动切换）</p>
<ul>
<li>对应 一个调用链路 （默认值为sentinel_default_context）</li>
<li>对应一个 entrancenode（在Context.enter时创建）</li>
</ul>
<p>一个resource （resource name为唯一标识）</p>
<ul>
<li>对应一个责任链实例（共享同一个 NodeSelectorSlot 实例以及 ClusterBuilderSlot实例）</li>
<li>对应一个ClusterNode（不同origin会在该ClusterNode下挂不同的数据节点）</li>
</ul>
<p>一个DefaultNode（维持调用树状结构）</p>
<ul>
<li>对应一个context下的一个resource，即它的纬度是context*resource，存在NodeSelectorSlot的map中（key为context name）</li>
</ul>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/imag9e.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image9.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h1 id="举例">举例</h1>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//规则</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initFlowRules</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    FlowRule rule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">    rule.setResource(<span class="string">"helloAnother"</span>);</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    <span class="comment">// Set limit QPS to 20.</span></span><br><span class="line">    rule.setCount(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    FlowRule rule2 = <span class="keyword">new</span> FlowRule();</span><br><span class="line">    rule2.setResource(<span class="string">"hello"</span>);</span><br><span class="line">    rule2.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    <span class="comment">// Set limit QPS to 2.</span></span><br><span class="line">    rule2.setCount(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    rules.add(rule);</span><br><span class="line">    rules.add(rule2);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源hello</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"hello"</span>, fallback = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid arg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Hello at %d"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源helloAnother</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"helloAnother"</span>, defaultFallback = <span class="string">"defaultFallback"</span>,</span><br><span class="line">                  exceptionsToIgnore = &#123;IllegalStateException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">String</span> <span class="title">helloAnother</span>(<span class="title">String</span> <span class="title">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || <span class="string">"bad"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"oops"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"foo"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"oops"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String temp=testService.hello(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">" "</span> + temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> interval=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            interval=<span class="number">100</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Float qps=Float.parseFloat(args[<span class="number">0</span>]);</span><br><span class="line">            interval=Math.round(<span class="number">1000</span>/qps);</span><br><span class="line">        &#125;</span><br><span class="line">        doTest(interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">int</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(interval);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                firstLevel();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage() + <span class="string">" block"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">firstLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">        <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"firstLevel"</span>, EntryType.IN))&#123;</span><br><span class="line">            <span class="keyword">if</span> (count%(interval*<span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"firstLevel"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            secondLevel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"firstLevel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">secondLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">        <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"secondLevel"</span>,EntryType.OUT))&#123;</span><br><span class="line">            <span class="keyword">if</span> (count%(interval*<span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"secondLevel"</span>);</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"secondLevel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://github.com/sentinel-group/sentinel-awesome" target="_blank" rel="noopener">https://github.com/sentinel-group/sentinel-awesome</a></p>
<p><a href="https://www.javadoop.com/post/sentinel" target="_blank" rel="noopener">https://www.javadoop.com/post/sentinel</a></p>
<p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Sentinel%EF%BC%88%E5%AE%8C%EF%BC%89/01%20%E5%BC%80%E7%AF%87%E8%AF%8D%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86.md" target="_blank" rel="noopener">http://learn.lianglianglee.com/</a></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel学习笔记:sentinel-cluster</title>
    <url>/2021/07/10/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cluster/</url>
    <content><![CDATA[<h1 id="简介"><strong>简介</strong></h1>
<p>由于流量存在不均匀的情况，单机限流无法实现准确的集群限流，往往在总流量没有到达集群阈值的情况下，集群中的某些机器就开始限流。例如一个集群限流阈值为200qps，由两个节点组成，那么每个节点限流配置100qps，在这种配置下即便集群流量未到达200qps，单个节点也有可能到达100qps而开始限流。而集群限流就是为这种场景服务的，目的就是实现精确地控制整个集群的 QPS。</p>
<h1 id="模块简介"><strong>模块简介</strong></h1>
<p><strong>sentinel-cluster-common-default：</strong>公共模块，定义通信协议，包括编码器和解码器接口、请求和响应实体（数据包），与底层使用哪种通信框架无关</p>
<p><strong>sentinel-cluster-client-default：</strong>集群限流客户端模块，实现公共模块定义的接口，使用 Netty 进行通信，实现自动连接与掉线重连、提供连接配置 API</p>
<p><strong>sentinel-cluster-server-default：</strong>集群限流服务端模块，实现公共模块定义的接口，使用 Netty 进行通信，同时提供扩展接口对接规则判断的具体实现（TokenService）</p>
<p><strong>sentinel-cluster-server-envoy-rls：</strong>提供了Envoy 集群流量控制，使sentinel具有在Service Mesh下的流控能力</p>
<h1 id="核心原理"><strong>核心原理</strong></h1>
<h2 id="单机限流流程"><strong>单机限流流程</strong></h2>
<ol type="1">
<li>FlowSlot 作为切入点，在 entry 方法中调用 FlowRuleChecker#checkFlow 方法判断是否限流；</li>
<li>FlowRuleChecker 根据资源名称从规则管理器获取配置的限流规则，遍历限流规则；</li>
<li>根据限流规则的 clusterMode 决定走本地限流逻辑还是走集群限流逻辑；</li>
<li>如果是本地限流，则调用流量效果控制器判断是否拒绝当前请求。</li>
</ol>
<p>由于网络延迟的存在，Sentinel 集群限流并未实现匀速排队流量效果控制，也没有支持冷启动，而只支持直接拒绝请求的流控效果。（具有优先级的流量在一定情况下可以尝试抢占之后的时间窗口的指标，见core部分DefaultController）</p>
<h2 id="集群限流流程"><strong>集群限流流程</strong></h2>
<p>在上述第（3）步中如判断为集群限流，则通过远程调用向集群限流服务端（TokenService）发起调用，由TokenService判断是否拒绝请求。结合令牌桶的思想，TokenService类似于令牌发放员，负责生产令牌，客户端向服务端申请令牌。</p>
<h1 id="服务模式"><strong>服务模式</strong></h1>
<p>Sentinel 集群限流客户端与集群限流服务端通信只保持一个长连接，底层通信基于 Netty 框架实现，自定义通信协议，并且数据包较小，网络 I/O 性能方面影响不大。</p>
<p>Sentinel 集群限流对限流服务端的可用性要求不高，当限流服务端挂掉时，可回退为本地限流。</p>
<h2 id="嵌入模式"><strong>嵌入模式</strong></h2>
<p>简单理解为，TokenService作为应用的内置服务同应用一起启动，可动态挑选一个节点作为TokenService（不具备类似主从自动切换的功能）</p>
<h2 id="独立模式"><strong>独立模式</strong></h2>
<p>单独部署的TokenService，可以为多个服务提供集群限流支持</p>
<h2 id="整体扩展架构"><strong>整体扩展架构</strong></h2>
<figure>
<img src="/2021/07/10/Sentinel学习笔记-sentinel-cluste/image.png" alt="" /><figcaption>来源见文末</figcaption>
</figure>
<h1 id="核心类及流程"><strong>核心类及流程</strong></h1>
<figure>
<img src="/2021/07/10/Sentinel学习笔记-sentinel-cluste/imag2e.png" alt="" /><figcaption>来源见文末</figcaption>
</figure>
<h2 id="sentinel-core-模块的-cluster-包"><strong>sentinel-core 模块的 cluster 包</strong></h2>
<p>定义了实现集群限流功能的相关接口</p>
<ul>
<li>TokenService：定义客户端向服务端申请 token 的接口，由 FlowRuleChecker 调用</li>
<li>ClusterTokenClient：集群限流客户端需要实现的接口，继承 TokenService</li>
<li>ClusterTokenServer：集群限流服务端需要实现的接口</li>
<li>EmbeddedClusterTokenServer：支持嵌入模式的集群限流服务端需要实现的接口，继承 TokenService、ClusterTokenServer</li>
</ul>
<p>在上图中DefaultClusterTokenClient是 sentinel-cluster-client-default 模块中的 ClusterTokenClient 接口实现类，DefaultTokenService 与 DefaultEmbeddedTokenServer 分别是 sentinel-cluster-server-default 模块中的 ClusterTokenServer 接口与 EmbeddedClusterTokenServer 接口的实现类。</p>
<p>当使用嵌入模式启用集群限流服务端时，使用的是 EmbeddedClusterTokenServer，否则使用 ClusterTokenServer，通过 Java SPI 实现</p>
<h2 id="集群限流客户端"><strong>集群限流客户端</strong></h2>
<p>与单机限流的不同之处从FlowRuleChecker#canPassCheck开始，在该方法中若判断为集群限流则调用FlowRuleChecker#passClusterCheck方法</p>
<h3 id="flowrulecheckerpassclustercheck"><strong>FlowRuleChecker#passClusterCheck(……)</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passClusterCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取TokenService实例</span></span><br><span class="line">        TokenService clusterService = pickClusterService();</span><br><span class="line">        <span class="keyword">if</span> (clusterService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> fallbackToLocalOrPass(rule, context, node, acquireCount, prioritized);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取集群限流规则的唯一全局id</span></span><br><span class="line">        <span class="keyword">long</span> flowId = rule.getClusterConfig().getFlowId();</span><br><span class="line">        <span class="comment">//申请令牌</span></span><br><span class="line">        TokenResult result = clusterService.requestToken(flowId, acquireCount, prioritized);</span><br><span class="line">        <span class="comment">//根据结果判断是否拒绝请求</span></span><br><span class="line">        <span class="keyword">return</span> applyTokenResult(result, rule, context, node, acquireCount, prioritized);</span><br><span class="line">        <span class="comment">// If client is absent, then fallback to local mode.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        RecordLog.warn(<span class="string">"[FlowRuleChecker] Request cluster token unexpected failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback to local flow control when token client or server for this rule is not available.</span></span><br><span class="line">    <span class="comment">// If fallback is not enabled, then directly pass.</span></span><br><span class="line">    <span class="keyword">return</span> fallbackToLocalOrPass(rule, context, node, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pickclusterservice"><strong>pickClusterService()</strong></h3>
<p>如果当前节点是客户端角色，获取ClusterTokenClient实例<strong>；</strong>如果当前节点是服务端角色（嵌入式），获取EmbeddedClusterTokenServer实例</p>
<h3 id="requesttokenflowid-acquirecount-prioritized"><strong>requestToken(flowId, acquireCount, prioritized)</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TokenResult <span class="title">requestToken</span><span class="params">(Long flowId, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查输入有效性</span></span><br><span class="line">    <span class="keyword">if</span> (notValidRequest(flowId, acquireCount)) &#123;</span><br><span class="line">        <span class="keyword">return</span> badRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造请求体</span></span><br><span class="line">    FlowRequestData data = <span class="keyword">new</span> FlowRequestData().setCount(acquireCount)</span><br><span class="line">        .setFlowId(flowId).setPriority(prioritized);</span><br><span class="line">    <span class="comment">//构造请求</span></span><br><span class="line">    ClusterRequest&lt;FlowRequestData&gt; request = <span class="keyword">new</span> ClusterRequest&lt;&gt;(ClusterConstants.MSG_TYPE_FLOW, data);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//发送请求，通过netty建立的连接发送</span></span><br><span class="line">        TokenResult result = sendTokenRequest(request);</span><br><span class="line">        logForResult(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        ClusterClientStatLogUtil.log(ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenResult(TokenResultStatus.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="applytokenresultresult-rule-context-node-acquirecount-prioritized"><strong>applyTokenResult(result, rule, context, node, acquireCount, prioritized)</strong></h3>
<ul>
<li>当响应状态码为 OK 时放行请求；</li>
<li>当响应状态码为 SHOULD_WAIT 时，休眠指定时间再放行请求；</li>
<li>当响应状态码为 BLOCKED，直接拒绝请求；</li>
<li>其它状态码均代表调用失败，根据规则配置的 fallbackToLocalWhenFail 是否为 true，决定是否回退为本地限流，如果需要回退为本地限流模式，则调用 passLocalCheck 方法重新判断。</li>
</ul>
<h2 id="集群限流服务端"><strong>集群限流服务端</strong></h2>
<p>从客户端发来的requestToken请求最后交由com.alibaba.csp.sentinel.cluster.flow.DefaultTokenService#requestToken方法处理</p>
<h3 id="defaulttokenservicerequesttokenlong-ruleid-int-acquirecount-boolean-prioritized"><strong>DefaultTokenService#requestToken(Long ruleId, int acquireCount, boolean prioritized)</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TokenResult <span class="title">requestToken</span><span class="params">(Long ruleId, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//验证规则有效性</span></span><br><span class="line">    <span class="keyword">if</span> (notValidRequest(ruleId, acquireCount)) &#123;</span><br><span class="line">        <span class="keyword">return</span> badRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The rule should be valid.</span></span><br><span class="line">    <span class="comment">//获取对应规则</span></span><br><span class="line">    FlowRule rule = ClusterFlowRuleManager.getFlowRuleById(ruleId);</span><br><span class="line">    <span class="keyword">if</span> (rule == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenResult(TokenResultStatus.NO_RULE_EXISTS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取令牌</span></span><br><span class="line">    <span class="keyword">return</span> ClusterFlowChecker.acquireClusterToken(rule, acquireCount, prioritized);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clusterparamflowcheckeracquireclustertoken"><strong>ClusterParamFlowChecker#acquireClusterToken</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> TokenResult <span class="title">acquireClusterToken</span><span class="params">(<span class="comment">/*@Valid*/</span> FlowRule rule, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    Long id = rule.getClusterConfig().getFlowId();</span><br><span class="line">    <span class="comment">//命名空间纬度的全局阈值</span></span><br><span class="line">    <span class="keyword">if</span> (!allowProceed(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenResult(TokenResultStatus.TOO_MANY_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取数据统计滑动窗口</span></span><br><span class="line">    ClusterMetric metric = ClusterMetricStatistics.getMetric(id);</span><br><span class="line">    <span class="keyword">if</span> (metric == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenResult(TokenResultStatus.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取已通过数</span></span><br><span class="line">    <span class="keyword">double</span> latestQps = metric.getAvg(ClusterFlowEvent.PASS);</span><br><span class="line">    <span class="comment">//计算阈值</span></span><br><span class="line">    <span class="keyword">double</span> globalThreshold = calcGlobalThreshold(rule) * ClusterServerConfigManager.getExceedCount();</span><br><span class="line">    <span class="comment">//剩余通过数=阈值-已通过数-请求数</span></span><br><span class="line">    <span class="keyword">double</span> nextRemaining = globalThreshold - latestQps - acquireCount;</span><br><span class="line">    <span class="comment">//剩余通过数&gt;0直接放行</span></span><br><span class="line">    <span class="keyword">if</span> (nextRemaining &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> checking logic and metric operation should be separated.</span></span><br><span class="line">        metric.add(ClusterFlowEvent.PASS, acquireCount);</span><br><span class="line">        metric.add(ClusterFlowEvent.PASS_REQUEST, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prioritized) &#123;</span><br><span class="line">            <span class="comment">// Add prioritized pass.</span></span><br><span class="line">            metric.add(ClusterFlowEvent.OCCUPIED_PASS, acquireCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Remaining count is cut down to a smaller integer.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TokenResult(TokenResultStatus.OK)</span><br><span class="line">            .setRemaining((<span class="keyword">int</span>) nextRemaining)</span><br><span class="line">            .setWaitInMs(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//剩余通过数不足，但是是优先流量，允许占用之后指标，类似core部分DefaultControlle</span></span><br><span class="line">        <span class="keyword">if</span> (prioritized) &#123;</span><br><span class="line">            <span class="comment">// Try to occupy incoming buckets.</span></span><br><span class="line">            <span class="comment">//获取已经占用数</span></span><br><span class="line">            <span class="keyword">double</span> occupyAvg = metric.getAvg(ClusterFlowEvent.WAITING);</span><br><span class="line">            <span class="comment">//已经占用数小于允许占用的最大值（比例*阈值）</span></span><br><span class="line">            <span class="keyword">if</span> (occupyAvg &lt;= ClusterServerConfigManager.getMaxOccupyRatio() * globalThreshold) &#123;</span><br><span class="line">                <span class="comment">//计算占用后等待时间</span></span><br><span class="line">                <span class="keyword">int</span> waitInMs = metric.tryOccupyNext(ClusterFlowEvent.PASS, acquireCount, globalThreshold);</span><br><span class="line">                <span class="comment">// waitInMs &gt; 0 indicates pre-occupy incoming buckets successfully.</span></span><br><span class="line">                <span class="keyword">if</span> (waitInMs &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ClusterServerStatLogUtil.log(<span class="string">"flow|waiting|"</span> + id);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> TokenResult(TokenResultStatus.SHOULD_WAIT)</span><br><span class="line">                        .setRemaining(<span class="number">0</span>)</span><br><span class="line">                        .setWaitInMs(waitInMs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Or else occupy failed, should be blocked.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Blocked.</span></span><br><span class="line">        metric.add(ClusterFlowEvent.BLOCK, acquireCount);</span><br><span class="line">        metric.add(ClusterFlowEvent.BLOCK_REQUEST, <span class="number">1</span>);</span><br><span class="line">        ClusterServerStatLogUtil.log(<span class="string">"flow|block|"</span> + id, acquireCount);</span><br><span class="line">        ClusterServerStatLogUtil.log(<span class="string">"flow|block_request|"</span> + id, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (prioritized) &#123;</span><br><span class="line">            <span class="comment">// Add prioritized block.</span></span><br><span class="line">            metric.add(ClusterFlowEvent.OCCUPIED_BLOCK, acquireCount);</span><br><span class="line">            ClusterServerStatLogUtil.log(<span class="string">"flow|occupied_block|"</span> + id, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> blockedResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clusterparamflowcheckercalcglobalthreshold"><strong>ClusterParamFlowChecker#calcGlobalThreshold</strong></h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">calcGlobalThreshold</span><span class="params">(ParamFlowRule rule, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取阈值</span></span><br><span class="line">    <span class="keyword">double</span> count = getRawThreshold(rule, value);</span><br><span class="line">    <span class="comment">//当阈值类型为集群总 QPS 时，直接使用限流规则的阈值（count）；</span></span><br><span class="line">    <span class="comment">//当阈值类型为单机均摊时，根据规则 ID 获取当前连接的客户端总数，将当前连接的客户端总数乘以限流规则的阈值（count）作为集群总 QPS 阈值。</span></span><br><span class="line">    <span class="keyword">switch</span> (rule.getClusterConfig().getThresholdType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ClusterRuleConstant.FLOW_THRESHOLD_GLOBAL:</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">case</span> ClusterRuleConstant.FLOW_THRESHOLD_AVG_LOCAL:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">int</span> connectedCount = ClusterParamFlowRuleManager.getConnectedCount(rule.getClusterConfig().getFlowId());</span><br><span class="line">            <span class="keyword">return</span> count * connectedCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clustermetrictryoccupynext"><strong>ClusterMetric#tryOccupyNext</strong></h3>
<p>简化版的DefaultControlle，只尝试占用下一个样本窗口的指标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryOccupyNext</span><span class="params">(ClusterFlowEvent event, <span class="keyword">int</span> acquireCount, <span class="keyword">double</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前窗口通过数</span></span><br><span class="line">    <span class="keyword">double</span> latestQps = getAvg(ClusterFlowEvent.PASS);</span><br><span class="line">    <span class="comment">//判断能否占用之后窗口</span></span><br><span class="line">    <span class="keyword">if</span> (!canOccupy(event, acquireCount, latestQps, threshold)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    metric.addOccupyPass(acquireCount);</span><br><span class="line">    add(ClusterFlowEvent.WAITING, acquireCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span> / metric.getSampleCount();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canOccupy</span><span class="params">(ClusterFlowEvent event, <span class="keyword">int</span> acquireCount, <span class="keyword">double</span> latestQps, <span class="keyword">double</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取未来窗口的通过数</span></span><br><span class="line">    <span class="keyword">long</span> headPass = metric.getFirstCountOfWindow(event);</span><br><span class="line">    <span class="comment">//获取未来窗口占用数</span></span><br><span class="line">    <span class="keyword">long</span> occupiedCount = metric.getOccupiedCount(event);</span><br><span class="line">    <span class="comment">//  bucket to occupy (= incoming bucket)</span></span><br><span class="line">    <span class="comment">//       ↓</span></span><br><span class="line">    <span class="comment">// | head bucket |    |    |    | current bucket |</span></span><br><span class="line">    <span class="comment">// +-------------+----+----+----+----------- ----+</span></span><br><span class="line">    <span class="comment">//   (headPass)</span></span><br><span class="line">    <span class="comment">//判断当前窗口已通过数+（请求数+未来窗口被占用数）-未来窗口通过数（重复计算所以减去）是否小于阈值</span></span><br><span class="line">    <span class="keyword">return</span> latestQps + (acquireCount + occupiedCount) - headPass &lt;= threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="滑动窗口"><strong>滑动窗口</strong></h3>
<p>集群限流使用的滑动窗口并非 sentinel-core 模块下实现的滑动窗口，而是 sentinel-cluster-server-default 模块自己实现的滑动窗口</p>
<p>实现集群限流需要收集的指标数据有以下几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ClusterFlowEvent &#123;</span><br><span class="line">    PASS,</span><br><span class="line">    BLOCK,</span><br><span class="line">    PASS_REQUEST,</span><br><span class="line">    BLOCK_REQUEST,</span><br><span class="line">    OCCUPIED_PASS,</span><br><span class="line">    OCCUPIED_BLOCK,</span><br><span class="line">    WAITING</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PASS：已经发放的令牌总数</li>
<li>BLOCK：令牌申请被驳回的总数</li>
<li>PASS_REQUEST：被放行的请求总数</li>
<li>BLOCK_REQUEST：被拒绝的请求总数</li>
<li>OCCUPIED_PASS：预占用，已经发放的令牌总数</li>
<li>OCCUPIED_BLOCK：预占用，令牌申请被驳回的总数</li>
<li>WAITING：当前等待下一个时间窗口到来的请求总数</li>
</ul>
<p>除统计的指标项与 sentinel-core 包下实现的滑动窗口统计的指标项有些区别外，实现方式都一致。</p>
<h1 id="总结"><strong>总结</strong></h1>
<p>集群限流并非解决请求倾斜问题，在请求倾斜严重的情况下，集群限流可能会导致某些节点的流量过高，导致系统的负载过高，这时就需要使用系统自适应限流、熔断降级作为兜底解决方案。</p>
<h1 id="参考资料"><strong>参考资料</strong></h1>
<p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Sentinel%EF%BC%88%E5%AE%8C%EF%BC%89/18%20Sentinel%20%E9%9B%86%E7%BE%A4%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="noopener">http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Sentinel%EF%BC%88%E5%AE%8C%EF%BC%89/18%20Sentinel%20%E9%9B%86%E7%BE%A4%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89.md</a></p>
<p><a href="https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7" target="_blank" rel="noopener">https://github.com/alibaba/Sentinel/wiki/%E9%9B%86%E7%BE%A4%E6%B5%81%E6%8E%A7</a></p>
]]></content>
      <categories>
        <category>知识图谱</category>
      </categories>
      <tags>
        <tag>源码分析</tag>
        <tag>Sentinel</tag>
      </tags>
  </entry>
</search>
