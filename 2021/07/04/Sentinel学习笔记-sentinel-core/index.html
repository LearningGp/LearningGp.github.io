<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="源码分析,Sentinel," />










<meta name="description" content="有的没的 有蛮长时间没更新了，笔记一直有在做，不过暂时都放在本地了，因为有些还不太完整（选定的每篇范围太大也是一个原因）。加上最近在实习，大部分笔记放在内部的笔记软件中。不过因为Sentinel有很大一部分是开源的，所以将笔记中有关开源的分析部分重新整理出来公开了，这段时间应该陆续会有笔记被放到这边。 文中没标注的部分资料（图片）来源于文末参考链接。 经典限流算法 计数器算法 Sentin">
<meta property="og:type" content="article">
<meta property="og:title" content="Sentinel学习笔记:sentinel-core">
<meta property="og:url" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-core/index.html">
<meta property="og:site_name" content="LearningGp">
<meta property="og:description" content="有的没的 有蛮长时间没更新了，笔记一直有在做，不过暂时都放在本地了，因为有些还不太完整（选定的每篇范围太大也是一个原因）。加上最近在实习，大部分笔记放在内部的笔记软件中。不过因为Sentinel有很大一部分是开源的，所以将笔记中有关开源的分析部分重新整理出来公开了，这段时间应该陆续会有笔记被放到这边。 文中没标注的部分资料（图片）来源于文末参考链接。 经典限流算法 计数器算法 Sentin">
<meta property="og:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/image2.png">
<meta property="og:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/image1.png">
<meta property="og:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/image3.png">
<meta property="og:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/imag6e.png">
<meta property="og:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/ima8ge.png">
<meta property="og:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/imag9e.png">
<meta property="og:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/image9.png">
<meta property="article:published_time" content="2021-07-04T15:29:00.000Z">
<meta property="article:modified_time" content="2021-07-10T06:25:27.279Z">
<meta property="article:author" content="Arvin">
<meta property="article:tag" content="源码分析">
<meta property="article:tag" content="Sentinel">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cor/image2.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/07/04/Sentinel学习笔记-sentinel-core/"/>





  <title>Sentinel学习笔记:sentinel-core | LearningGp</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LearningGp</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-commenting"></i> <br />
            
            留言板
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/04/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LearningGp">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Sentinel学习笔记:sentinel-core</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-04T23:29:00+08:00">
                2021-07-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" itemprop="url" rel="index">
                    <span itemprop="name">知识图谱</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="有的没的">有的没的</h1>
<p>有蛮长时间没更新了，笔记一直有在做，不过暂时都放在本地了，因为有些还不太完整（选定的每篇范围太大也是一个原因）。加上最近在实习，大部分笔记放在内部的笔记软件中。不过因为Sentinel有很大一部分是开源的，所以将笔记中有关开源的分析部分重新整理出来公开了，这段时间应该陆续会有笔记被放到这边。 文中没标注的部分资料（图片）来源于文末参考链接。</p>
<h1 id="经典限流算法">经典限流算法</h1>
<h2 id="计数器算法">计数器算法</h2>
<p>Sentinel 中默认实现的 QPS 限流算法和 THREADS 限流算法都属于计数器算法。QPS 限流的默认算法是通过判断当前时间窗口（1 秒）的 pass（被放行的请求数量）指标数据判断，如果 pass 总数已经大于等于限流的 QPS 阈值，则直接拒绝当前请求，每通过一个请求当前时间窗口的 pass 指标计数加 1。THREADS 限流的实现是通过判断当前资源并行占用的线程数是否已经达到阈值，是则直接拒绝当前请求，每通过一个请求 THREADS 计数加 1，每完成一个请求 THREADS 计数减 1。</p>
<h2 id="漏桶算法leaky-bucket">漏桶算法（Leaky Bucket）</h2>
<p>漏桶就像在一个桶的底部开一个洞，不控制水放入桶的速度，而通过底部漏洞的大小控制水流失的速度，当水放入桶的速率小于或等于水通过底部漏洞流出的速率时，桶中没有剩余的水，而当水放入桶的速率大于漏洞流出的速率时，水就会逐渐在桶中积累，当桶装满水时，若再向桶中放入水，则放入的水就会溢出。我们把水换成请求，往桶里放入请求的速率就是接收请求的速率，而水流失就是请求通过，水溢出就是请求被拒绝。</p>
<h2 id="令牌桶算法token-bucket">令牌桶算法（Token Bucket）</h2>
<p>令牌桶不存放请求，而是存放为请求生成的令牌（Token），只有拿到令牌的请求才能通过。原理就是以固定速率往桶里放入令牌，每当有请求过来时，都尝试从桶中获取令牌，如果能拿到令牌请求就能通过。当桶放满令牌时，多余的令牌就会被丢弃，而当桶中的令牌被用完时，请求拿不到令牌就无法通过。</p>
<h1 id="数据模型">数据模型</h1>
<h2 id="核心类">核心类</h2>
<h3 id="arraymetric">ArrayMetric</h3>
<p>Metric的实现类，数据节点的addRtAndSuccess最后会落到该类上，该类也是sentinel记录数据模型的最外层包装</p>
<p>内部持有一个<code>LeapArray&lt;MetricBucket&gt; data</code>数据结构作为对窗口的包装，所有操作都会落到该数据结构上</p>
<p>构造方法通过传入参数的差异，为data赋值不同子类的引用（秒级窗口OccupiableBucketLeapArray，分钟级窗口BucketLeapArray）</p>
<h3 id="leaparray">LeapArray</h3>
<p>内部持有一个<code>AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt;</code>的数据结构作为实际容纳窗口的容器，各种操作会在该类中获取对应的<code>WindowWrap&lt;T&gt;</code>再进行相关操作</p>
<p><strong>成员变量</strong></p>
<p>protected int windowLengthInMs;</p>
<p>每个窗口长度（Ms）</p>
<p>protected int sampleCount;</p>
<p>滑动窗口内样本个数</p>
<p>protected int intervalInMs;</p>
<p>LeapArray总时间（Ms）</p>
<p>private double intervalInSecond;</p>
<p>LeapArray总时间（s）</p>
<p>protected final AtomicReferenceArray&lt;WindowWrap<T>&gt; array;</p>
<p>private final ReentrantLock updateLock = new ReentrantLock();</p>
<p>更新<code>WindowWrap&lt;T&gt;</code>的锁</p>
<h3 id="windowwrap">WindowWrap</h3>
<p>窗口包装类，主要用于包装MetricBucket，记录窗口元信息</p>
<p><strong>成员变量</strong></p>
<p>private final long windowLengthInMs;</p>
<p>窗口长度</p>
<p>private long windowStart;</p>
<p>窗口开始时间</p>
<p>private T value;</p>
<p>被包装的类</p>
<h3 id="metricbucket">MetricBucket</h3>
<p>实际数据存放类</p>
<p>维护了一个LongAdder数组counters，用于记录各种数据，包括以下几种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MetricEvent &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Normal pass.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PASS,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Normal block.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCK,</span><br><span class="line">    EXCEPTION,</span><br><span class="line">    SUCCESS,</span><br><span class="line">    RT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Passed in future quota (pre-occupied, since 1.5.0).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    OCCUPIED_PASS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="核心方法">核心方法</h2>
<h3 id="获取数据以success为例">获取数据（以success为例）</h3>
<p>com.alibaba.csp.sentinel.slots.statistic.metric.ArrayMetric#success</p>
<p>获取窗口内的success个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//方法本身是用来获取当前时间所在窗口，在这边被用于更新当前时间所在窗口</span></span><br><span class="line">    data.currentWindow();</span><br><span class="line">    <span class="keyword">long</span> success = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取整个窗口内的所有MetricBucket</span></span><br><span class="line">    List&lt;MetricBucket&gt; list = data.values();</span><br><span class="line">    <span class="keyword">for</span> (MetricBucket window : list) &#123;</span><br><span class="line">        <span class="comment">//累加计算总和</span></span><br><span class="line">        success += window.success();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>com.alibaba.csp.sentinel.slots.statistic.base.LeapArray#currentWindow(long)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = calculateTimeIdx(timeMillis);</span><br><span class="line">        <span class="comment">// Calculate current bucket start time.</span></span><br><span class="line">        <span class="keyword">long</span> windowStart = calculateWindowStart(timeMillis);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Get bucket item at given time from the array.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * (1) Bucket is absent, then just create a new bucket and CAS update to circular array.</span></span><br><span class="line"><span class="comment">         * (2) Bucket is up-to-date, then just return the bucket.</span></span><br><span class="line"><span class="comment">         * (3) Bucket is deprecated, then reset current bucket and clean all deprecated buckets.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            WindowWrap&lt;T&gt; old = array.get(idx);</span><br><span class="line">            <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *     B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">                 * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">                 * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">                 *                             ^</span></span><br><span class="line"><span class="comment">                 *                          time=888</span></span><br><span class="line"><span class="comment">                 *            bucket is empty, so create new and update</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * If the old bucket is absent, then we create a new bucket at &#123;@code windowStart&#125;,</span></span><br><span class="line"><span class="comment">                 * then try to update circular array via a CAS operation. Only one thread can</span></span><br><span class="line"><span class="comment">                 * succeed to update, while other threads yield its time slice.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">                <span class="keyword">if</span> (array.compareAndSet(idx, <span class="keyword">null</span>, window)) &#123;</span><br><span class="line">                    <span class="comment">// Successfully updated, return the created bucket.</span></span><br><span class="line">                    <span class="keyword">return</span> window;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *     B0       B1      B2     B3      B4</span></span><br><span class="line"><span class="comment">                 * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">                 * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">                 *                             ^</span></span><br><span class="line"><span class="comment">                 *                          time=888</span></span><br><span class="line"><span class="comment">                 *            startTime of Bucket 3: 800, so it's up-to-date</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * If current &#123;@code windowStart&#125; is equal to the start timestamp of old bucket,</span></span><br><span class="line"><span class="comment">                 * that means the time is within the bucket, so directly return the bucket.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">return</span> old;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *   (old)</span></span><br><span class="line"><span class="comment">                 *             B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">                 * |_______||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">                 * ...    1200     1400    1600    1800    2000    2200  timestamp</span></span><br><span class="line"><span class="comment">                 *                              ^</span></span><br><span class="line"><span class="comment">                 *                           time=1676</span></span><br><span class="line"><span class="comment">                 *          startTime of Bucket 2: 400, deprecated, should be reset</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * If the start timestamp of old bucket is behind provided time, that means</span></span><br><span class="line"><span class="comment">                 * the bucket is deprecated. We have to reset the bucket to current &#123;@code windowStart&#125;.</span></span><br><span class="line"><span class="comment">                 * Note that the reset and clean-up operations are hard to be atomic,</span></span><br><span class="line"><span class="comment">                 * so we need a update lock to guarantee the correctness of bucket update.</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * The update lock is conditional (tiny scope) and will take effect only when</span></span><br><span class="line"><span class="comment">                 * bucket is deprecated, so in most cases it won't lead to performance loss.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// Successfully get the update lock, now we reset the bucket.</span></span><br><span class="line">                        <span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        updateLock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                    Thread.yield();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123;</span><br><span class="line">                <span class="comment">// Should not go through here, as the provided time is already behind.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注释非常详细，需要注意的是resetWindowTo方法，不同子类有不同的实现</p>
<ul>
<li>BucketLeapArray：重置窗口开始时间，将各种数据置为0</li>
<li>OccupiableBucketLeapArray：重置窗口开始时间，将borrowArray中对应时间的MetricBucket的数据作为窗口的数据，而不是直接归零（具体作用在流控中解释）</li>
</ul>
<p>com.alibaba.csp.sentinel.slots.statistic.base.LeapArray#values()</p>
<p>com.alibaba.csp.sentinel.slots.statistic.base.LeapArray#values(long)</p>
<p>获取窗口内的所有有效的（非过期）MetricBucket，组成list返回</p>
<h3 id="增加数据以addsuccess为例">增加数据（以addSuccess为例）</h3>
<p>com.alibaba.csp.sentinel.slots.statistic.metric.ArrayMetric#addSuccess</p>
<p>调用currentWindow获取当前窗口后调用value()获取MetricBucket再调用addSuccess(count)方法</p>
<h2 id="滑动窗口类型">滑动窗口类型</h2>
<h3 id="分钟级滑动窗口">分钟级滑动窗口</h3>
<p>窗口总长度60秒，每个样本窗口1秒，总共60个样本窗口</p>
<p>private transient Metric rollingCounterInMinute = new ArrayMetric(60, 60 * 1000, false);</p>
<h3 id="秒级滑动窗口">秒级滑动窗口</h3>
<p>窗口总长度1秒，每个样本窗口500ms，总共2个样本窗口</p>
<p>private transient volatile Metric rollingCounterInSecond =<br />
new ArrayMetric(SampleCountProperty.<em>SAMPLE_COUNT</em>,IntervalProperty.<em>INTERVAL</em>);</p>
<p>PS：秒级窗口不精确，监控中的秒级数据来自于分钟级窗口，只有需要最近1秒的数据时才会使用秒级滑动窗口的值（详情可以看文首第二个链接）</p>
<h1 id="切入流程">切入流程</h1>
<p>（以SpringBoot版本为例）</p>
<h2 id="通过aop机制织入">通过AOP机制织入</h2>
<p>com.alibaba.csp.sentinel.annotation.aspectj.SentinelResourceAspect</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelResourceAspect</span> <span class="keyword">extends</span> <span class="title">AbstractSentinelAspectSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.alibaba.csp.sentinel.annotation.SentinelResource)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sentinelResourceAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"sentinelResourceAnnotationPointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeResourceWithSentinel</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取方法</span></span><br><span class="line">        Method originMethod = resolveMethod(pjp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取注解</span></span><br><span class="line">        SentinelResource annotation = originMethod.getAnnotation(SentinelResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (annotation == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Should not go through here.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Wrong state for SentinelResource annotation"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取资源名称</span></span><br><span class="line">        String resourceName = getResourceName(annotation.value(), originMethod);</span><br><span class="line">        <span class="comment">//获取类型（OUT or IN）</span></span><br><span class="line">        EntryType entryType = annotation.entryType();</span><br><span class="line">        Entry entry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//核心部分，入口</span></span><br><span class="line">            entry = SphU.entry(resourceName, entryType, <span class="number">1</span>, pjp.getArgs());</span><br><span class="line">            <span class="comment">//通过，允许调用</span></span><br><span class="line">            Object result = pjp.proceed();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException ex) &#123;</span><br><span class="line">            <span class="comment">//不通过，不允许调用</span></span><br><span class="line">            <span class="keyword">return</span> handleBlockException(pjp, annotation, ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            Tracer.trace(ex);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//退出入口</span></span><br><span class="line">                entry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="entry">Entry</h2>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image2.png" alt="" /><figcaption>LearningGp</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">entryWithPriority</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取ThreadLocal中已经存在的context</span></span><br><span class="line">    Context context = ContextUtil.getContext();</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> NullContext) &#123;</span><br><span class="line">        <span class="comment">// The &#123;@link NullContext&#125; indicates that the amount of context has exceeded the threshold,</span></span><br><span class="line">        <span class="comment">// so here init the entry only. No rule checking will be done.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Using default context.</span></span><br><span class="line">        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global switch is close, no rule checking will do.</span></span><br><span class="line">    <span class="keyword">if</span> (!Constants.ON) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过SPI机制加载处理链</span></span><br><span class="line">    ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Means amount of resources (slot chain) exceeds &#123;@link Constants.MAX_SLOT_CHAIN_SIZE&#125;,</span></span><br><span class="line"><span class="comment">         * so no rule checking will be done.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造Entry实例</span></span><br><span class="line">    Entry e = <span class="keyword">new</span> CtEntry(resourceWrapper, chain, context);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        /进入处理链</span><br><span class="line">        chain.entry(context, resourceWrapper, <span class="keyword">null</span>, count, prioritized, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e1) &#123;</span><br><span class="line">        e.exit(count, args);</span><br><span class="line">        <span class="keyword">throw</span> e1;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">        <span class="comment">// This should not happen, unless there are errors existing in Sentinel internal.</span></span><br><span class="line">        RecordLog.info(<span class="string">"Sentinel unexpected exception"</span>, e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后在处理链指针不为空的情况下按序调用进入方法并返回</p>
<h1 id="核心类-1">核心类</h1>
<h2 id="context">Context</h2>
<p>Context 代表调用链路上下文，贯穿一次调用链路中的所有 Entry。Context 维持着入口节点（entranceNode）、本次调用链路的 curNode、调用来源（origin）等信息。Context 名称即为调用链路入口名称。</p>
<p>Context 通过 ThreadLocal 传递，只在调用链路的入口处创建。</p>
<p>Context 的字段说明：</p>
<ul>
<li>name：Context 的名称。</li>
<li>entranceNode：当前调用树的入口节点，类型为 EntranceNode。同一个入口的资源，每个资源对应一个 DefaultNode，entranceNode#childList 用于存储这些资源的 DefaultNode。</li>
<li>curEntry：当前 Entry（CtEntry）。</li>
<li>origin：调用来源的名称，即服务消费者的名称或者服务消费者的来源 IP，取决于服务消费者是否使用 Sentinel，由 Sentinel 适配层传递过来。例如：服务提供者是 Spring MVC 应用，且服务提供者使用 Sentinel 的 Web MVC 适配，那么 Sentinel 会尝试从请求头获取"S-user"，如果服务消费者有在请求头传递这个参数，那么就能够获取到</li>
</ul>
<h2 id="entry-1">Entry</h2>
<p>在调用 Context#getCurNode 方法获取调用链路上当前访问到的资源的 DefaultNode 时，实际是从 Context#curEntry 获取的，Entry 维护了当前资源的 DefaultNode，以及调用来源的 StatisticNode。</p>
<p>CtEntry 是 Entry 的直接子类</p>
<p>CtEntry 用于维护父子 Entry，每一次调用 SphU#entry 方法都会创建一个 CtEntry。如果服务 B 在处理一个请求的路径上会多次调用 SphU#entry，那么这些 CtEntry 会构成一个双向链表。在每次创建 CtEntry，都会将 Context.curEntry 设置为这个新的 CtEntry，双向链表的作用就是在调用 CtEntry#exit 方法时，能够将 Context.curEntry 还原为上一个资源的 CtEntry。</p>
<h2 id="node">Node</h2>
<p>用于持有实时统计的指标数据</p>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image1.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<p>Node实际上是数据节点，主要用于统计各种规则所需要的数据，如QPS，线程数等等。各个Node因为记录数据的不同有以下四个实现</p>
<h3 id="statisticnode">StatisticNode</h3>
<p>数据统计节点，核心数据是以下三个</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds statistics of the recent &#123;<span class="doctag">@code </span>INTERVAL&#125; seconds. The &#123;<span class="doctag">@code </span>INTERVAL&#125; is divided into time spans</span></span><br><span class="line"><span class="comment">     * by given &#123;<span class="doctag">@code </span>sampleCount&#125;.</span></span><br><span class="line"><span class="comment">     * 秒级滑动窗口，用于统计实时的 QPS，2 个时间窗口大小为 500 毫秒的 Bucket</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private transient volatile Metric rollingCounterInSecond = <span class="keyword">new</span> ArrayMetric(SampleCountProperty.SAMPLE_COUNT,</span><br><span class="line">                                                                           IntervalProperty.INTERVAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds statistics of the recent 60 seconds. The windowLengthInMs is deliberately set to 1000 milliseconds,</span></span><br><span class="line"><span class="comment">     * meaning each bucket per second, in this way we can get accurate statistics of each second.</span></span><br><span class="line"><span class="comment">     * 分级滑动窗口，用于保存最近一分钟内的历史指标数据，60 个 Bucket 数组，每个 Bucket 统计的时间窗口大小为 1 秒</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private transient Metric rollingCounterInMinute = <span class="keyword">new</span> ArrayMetric(<span class="number">60</span>, <span class="number">60</span> * <span class="number">1000</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The counter for thread count.</span></span><br><span class="line"><span class="comment">     * 并发线程数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">private LongAdder curThreadNum = <span class="keyword">new</span> LongAdder();</span><br></pre></td></tr></table></figure>
<p>滑动窗口使用场景</p>
<ul>
<li>获取前一秒被 Sentinel 拒绝的请求总数从分钟级滑动窗口获取</li>
<li>获取当前一秒内已经被 Sentinel 拒绝的请求总数则从秒级滑动窗口获取</li>
<li>获取最小耗时也是从秒级的滑动窗口获取</li>
</ul>
<p>StatisticNode 还负责统计并行占用的线程数，用于实现信号量隔离，按资源所能并发占用的最大线程数实现限流。通过控制并发线程数实现信号量隔离的好处就是不让一个接口同时使用完线程池所有线程</p>
<p>数据统计部分采用改进的滑动窗口的方式，时间窗口+Bucket，通过循环复用 Bucket 以减少 Bucket 的创建和销毁。在统计指标数据时，利用当前时间戳定位 Bucket，使用 LongAdder 统计时间窗口内的请求成功数、失败数、总耗时等指标数据优化了并发锁。Sentinel 通过定时任务递增时间戳以获取当前时间戳，避免了每次获取时间戳都使用 System 获取的性能消耗。//todo</p>
<h3 id="defaultnode">DefaultNode</h3>
<p>resource * context纬度数据统计节点，存在每个 NodeSelectorSlot 的map里</p>
<p>DefaultNode 字段说明：</p>
<ul>
<li>id：资源 ID，ResourceWrapper 对象。</li>
<li>childList：childList 是一个 Node（DefaultNode）集合，用于存放子节点。</li>
<li>clusterNode：clusterNode 字段是一个 ClusterNode，ClusterNode 也是 StatisticNode 的子类。</li>
</ul>
<h3 id="entrancenode">EntranceNode</h3>
<p>入口节点，名称相同的 Context 都使用同一个 EntranceNode</p>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image3.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h3 id="clusternode">ClusterNode</h3>
<p>统计每个资源全局的指标数据，以及统计该资源按调用来源区分的指标数据。全局数据指的是不区分调用链路，一个资源 ID 只对应一个 ClusterNode。</p>
<p>ClusterNode 字段说明：</p>
<ul>
<li>name：资源名称</li>
<li>resourceType：资源类型</li>
<li>originCountMap：维护每个调用来源的指标数据统计数据（StatisticNode）</li>
</ul>
<h2 id="root与调用树">Root与调用树</h2>
<p>Constants 常量类用于声明全局静态常量，Constants 有一个 ROOT 静态字段，类型为 EntranceNode。</p>
<p>在调用 ContextUtil#enter 方法时，如果还没有为当前入口创建 EntranceNode，则会为当前入口创建 EntranceNode，将其赋值给 Context.entranceNode，同时也会将这个 EntranceNode 添加到 Constants.ROOT 的子节点（childList）。资源对应的 DefaultNode 则是在 NodeSelectorSlot 中创建，并赋值给 Context.curEntry.curNode。</p>
<p>Constants.ROOT、Context.entranceNode 与 Entry.curNode 三者关系如下图所示。</p>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/imag6e.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h2 id="slot">Slot</h2>
<p>处理链上的插槽，核心逻辑所在</p>
<p>整体处理基于责任链模式，通过spi机制按顺序加载处理链，所有ProcessorSlot都继承AbstractLinkedProcessorSlot 类，从而组成单向链表，调用 fireEntry 方法逐个前进或者 fireExit 方法逐个后退</p>
<p>主要分成两类，一类数据统计（NodeSelectorSlot-&gt;ClusterBuilderSlot-&gt;StatisticSlot（logslot辅助用，暂时放在这类）），一类实现降级以及block</p>
<h3 id="数据统计slot">数据统计Slot</h3>
<h4 id="nodeselectorslot">NodeSelectorSlot</h4>
<p>这个 slot 主要负责收集资源的路径，并将这些资源的调用路径以树状结构存储起来，用于根据调用路径进行流量控制。</p>
<ul>
<li>为当前资源创建 DefaultNode，并且将 DefaultNode 赋值给 Context.curEntry.curNode</li>
<li>如果当前调用链路上只出现过一次 SphU#entry 的情况，将该 DefaultNode 添加到的 Context.entranceNode 的子节点，否则添加到 Context.curEntry.parent 的子节点（通过com.alibaba.csp.sentinel.context.Context#getLastNode实现）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">firstLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"firstLevel"</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">"firstLevel"</span>);</span><br><span class="line">        secondLevel();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"firstLevel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">secondLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">    <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"secondLevel"</span>))&#123;</span><br><span class="line">        System.out.println(<span class="string">"secondLevel"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"secondLevel"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时调用firstLevel方法会形成如下调用树</span></span><br><span class="line"></span><br><span class="line">                        ROOT (machine-root)</span><br><span class="line">                                /</span><br><span class="line">                    EntranceNode (context name: level-test)</span><br><span class="line">                           /                             </span><br><span class="line">        DefaultNode （resource name:firstLevel）    </span><br><span class="line">                    /                             </span><br><span class="line">DefaultNode （resource name:firstLevel）</span><br></pre></td></tr></table></figure>
<h4 id="clusterbuilderslot">ClusterBuilderSlot</h4>
<p>这一环的主要作用是构建 ClusterNode，为资源纬度的统计节点</p>
<ul>
<li>如果当前资源未创建 ClusterNode，则为资源创建 ClusterNode；</li>
<li>将 ClusterNode 赋值给当前资源的 DefaultNode.clusterNode；</li>
<li>如果调用来源（origin）不为空，则为调用来源创建 StatisticNode，用于实现按调用来源统计资源的指标数据，ClusterNode 持有每个调用来源的 StatisticNode。</li>
</ul>
<p>ps：ClusterBuilderSlot持有非静态<code>private volatile ClusterNode clusterNode = null;</code>，因为一个资源只会创建一个 ProcessorSlotChain，意味着 ClusterBuilderSlot 也只会创建一个，那么让 ClusterBuilderSlot 持有该资源的 ClusterNode 就可以省去每次都从 Map 中获取的步骤</p>
<h4 id="logslot">LogSlot</h4>
<p>进入时直接fire，在后续节点抛出BlockException后在这里将相关日志记录</p>
<h4 id="statisticslot">StatisticSlot</h4>
<p>负责进行数据统计，也是先fire，在后续节点处理完之后，在这里对统计的数据进行记录</p>
<h5 id="entry-方法">entry 方法</h5>
<h6 id="请求正常通过">请求正常通过</h6>
<ul>
<li>当前资源并行占用的线程数增加 1、当前时间窗口被放行的请求总数加 1</li>
<li>如果调用来源不为空，也将调用来源的 StatisticNode 的当前并行占用线程数加 1、当前时间窗口被放行的请求数加 1</li>
<li>如果流量类型为 IN，则将资源全局唯一的 ClusterNode 的并行占用线程数、当前时间窗口被放行的请求数都增加 1</li>
<li>回调所有 ProcessorSlotEntryCallback#onPass 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">node.increaseThreadNum();</span><br><span class="line">node.addPassRequest(count);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Add count for origin node.</span></span><br><span class="line">    context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class="line">    context.getCurEntry().getOriginNode().addPassRequest(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">    <span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">    Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class="line">    Constants.ENTRY_NODE.addPassRequest(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle pass event with registered entry callback handlers.</span></span><br><span class="line"><span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">    handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="捕获prioritywaitexception异常">捕获PriorityWaitException异常</h6>
<p>（特殊情况）</p>
<p>当捕获到 PriorityWaitException 异常时，说明当前请求已经被休眠了一会了，但请求还是允许通过的</p>
<ul>
<li>不需要为 DefaultNode 记录这个请求的指标数据</li>
<li>自增当前资源并行占用的线程数</li>
<li>为 ClusterNode 自增并行占用的线程数</li>
<li>回调所有 ProcessorSlotEntryCallback#onPass 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">node.increaseThreadNum();</span><br><span class="line"><span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// Add count for origin node.</span></span><br><span class="line">    context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">    <span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">    Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Handle pass event with registered entry callback handlers.</span></span><br><span class="line"><span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">    handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="捕获到-blockexception-异常">捕获到 BlockException 异常</h6>
<ul>
<li>将异常记录到调用链路上下文的当前 Entry（StatisticSlot 的 exit 方法会用到）</li>
<li>调用 DefaultNode#increaseBlockQps 方法记录当前请求被拒绝</li>
<li>将当前时间窗口的 block qps 这项指标数据的值加 1</li>
<li>如果调用来源不为空，让调用来源的 StatisticsNode 也记录当前请求被拒绝</li>
<li>如果流量类型为 IN，则让用于统计所有资源指标数据的 ClusterNode 也记录当前请求被拒绝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Blocked, set block exception to current entry.</span></span><br><span class="line">context.getCurEntry().setBlockError(e);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add block count.</span></span><br><span class="line">node.increaseBlockQps(count);</span><br><span class="line"><span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    context.getCurEntry().getOriginNode().increaseBlockQps(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">    <span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">    Constants.ENTRY_NODE.increaseBlockQps(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle block event with registered entry callback handlers.</span></span><br><span class="line"><span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">    handler.onBlocked(e, context, resourceWrapper, node, count, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
<h6 id="捕获到其他异常">捕获到其他异常</h6>
<ul>
<li>让 DefaultNode 记录当前请求异常</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Unexpected internal error, set error to current entry.</span></span><br><span class="line">context.getCurEntry().setError(e);</span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> e;</span><br></pre></td></tr></table></figure>
<h5 id="exit-方法">exit 方法</h5>
<p>由于StatisticSlot 在捕获异常时将异常记录到当前 Entry，exit 方法中通过 Context 可获取到当前 CtEntry，从当前 CtEntry 可获取 entry 方法中写入的异常，从而得知请求的具体状况，完成相应操作</p>
<ul>
<li>计算耗时</li>
<li>记录执行耗时与成功总数</li>
<li>自减当前资源占用线程数</li>
<li>来源不为空，减少来源的线程数</li>
<li>流量为In，让用于统计所有资源指标数据的 ClusterNode 也记录相关信息</li>
<li>调用回调方法</li>
</ul>
<p>PS:在 DefaultNode 的相关指标数据收集方法被调用时，ClusterNode 的对应方法也会被调用</p>
<h3 id="限流降级以及流控slot">限流降级以及流控Slot</h3>
<h4 id="authorityslot">AuthoritySlot</h4>
<p>权限控制，根据 <strong>origin</strong> 做黑白名单的控制</p>
<h4 id="systemslot">SystemSlot</h4>
<p>实现自适应限流（针对全局入口流量）<br />
com.alibaba.csp.sentinel.slots.system.SystemRuleManager#checkSystem</p>
<p>主要比较参数有successQps，curThreadNum，avgRt，<em>highestSystemLoad，highestCpuUsage</em></p>
<p>通过起一个后台线程（SystemMetricCollectorTask），每秒查询一次系统负载和CPU使用负载</p>
<p>第一版基于TCP BBR算法（结合自动化控制理论优化中PID controller）</p>
<p>第二版将系统指标（load/CPU usage）作为一个启动条件</p>
<p>com.alibaba.csp.sentinel.slots.system.SystemRuleManager#checkSystem</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkSystem</span><span class="params">(ResourceWrapper resourceWrapper)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (resourceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure the checking switch is on.</span></span><br><span class="line">    <span class="keyword">if</span> (!checkSystemStatus.get()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for inbound traffic only</span></span><br><span class="line">    <span class="keyword">if</span> (resourceWrapper.getEntryType() != EntryType.IN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total qps</span></span><br><span class="line">    <span class="keyword">double</span> currentQps = Constants.ENTRY_NODE == <span class="keyword">null</span> ? <span class="number">0.0</span> : Constants.ENTRY_NODE.successQps();</span><br><span class="line">    <span class="keyword">if</span> (currentQps &gt; qps) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"qps"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// total thread</span></span><br><span class="line">    <span class="keyword">int</span> currentThread = Constants.ENTRY_NODE == <span class="keyword">null</span> ? <span class="number">0</span> : Constants.ENTRY_NODE.curThreadNum();</span><br><span class="line">    <span class="keyword">if</span> (currentThread &gt; maxThread) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> rt = Constants.ENTRY_NODE == <span class="keyword">null</span> ? <span class="number">0</span> : Constants.ENTRY_NODE.avgRt();</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; maxRt) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"rt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load. BBR algorithm.</span></span><br><span class="line">    <span class="keyword">if</span> (highestSystemLoadIsSet &amp;&amp; getCurrentSystemAvgLoad() &gt; highestSystemLoad) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkBbr(currentThread)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"load"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cpu usage</span></span><br><span class="line">    <span class="keyword">if</span> (highestCpuUsageIsSet &amp;&amp; getCurrentCpuUsage() &gt; highestCpuUsage) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SystemBlockException(resourceWrapper.getName(), <span class="string">"cpu"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flowslot">FlowSlot</h4>
<p>负责流控功能的实现</p>
<p>由 ProcessorSlot、Checker、Rule、RuleManager 组合完成，ProcessorSlot作为入口，并持有对应的Checker，Checker根据Rule进行检查，RuleManager管理Rule</p>
<p>主要步骤如下</p>
<ol type="1">
<li>在 ProcessorSlot#entry 方法中调用 Checker#check 方法，并将 DefaultNode 传递给 Checker。</li>
<li>Checker 根据资源名称从 RuleManager 获取为该资源配置的规则。</li>
<li>Checker 从 传入context，以及node中根据rule和策略获取需要的node
<ol start="4" type="1">
<li>如果当前限流规则的 limitApp 不为 default，该限流规则只针对指定调用来源限流。当调用来源与当前限流规则的 limitApp 相等时：
<ol start="5" type="1">
<li>strategy 为 STRATEGY_DIRECT，则使用调用来源的 StatisticNode，实现针对调用来源限流。</li>
<li>strategy 为 STRATEGY_RELATE：根据限流规则配置的 refResource 获取引用资源的 ClusterNode，即使用引用资源的指标数据限流。通俗点说就是使用其它资源的指标数据限流，你的并发量高我就限流，让你多处理一点请求，等你并发量降低了，我就不限流了；</li>
<li>strategy 为 STRATEGY_CHAIN：使用当前资源的 DefauleNode，实现按调用链路的资源指标数据限流。</li>
</ol></li>
<li>当 limitApp 为 default 时，针对所有来源限流。
<ol start="9" type="1">
<li>strategy 为 STRATEGY_DIRECT，则使用当前资源的 ClusterNode。</li>
<li>strategy 为 STRATEGY_RELATE：使用引用资源的 ClusterNode；</li>
<li>strategy 为 STRATEGY_CHAIN：使用当前资源的 DefauleNode。</li>
</ol></li>
<li>如果 limitApp 为 other，且该资源的所有限流规则都没有针对当前的调用来源限流。
<ol start="12" type="1">
<li>如果 strategy 为 STRATEGY_DIRECT，则使用 origin 的 StatisticNode。</li>
</ol></li>
<li>strategy 为 STRATEGY_RELATE：使用引用资源的 ClusterNode</li>
<li>strategy 为 STRATEGY_CHAIN：使用当前资源的 DefauleNode</li>
</ol></li>
<li>根据配置调用对应的controller的canPass方法</li>
<li>从node中获取当前时间窗口的某项指标数据（QPS、avgRt 等）与规则的阈值对比，如果达到规则的阈值则抛出 Block 异常。</li>
</ol>
<h5 id="trafficshapingcontroller">TrafficShapingController</h5>
<p>实现流量塑形的controller主要有以下几种</p>
<h6 id="defaultcontroller">DefaultController</h6>
<p>实现快速失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前规则的限流阈值类型为 QPS，则返回node当前时间窗口统计的QPS；</span></span><br><span class="line">    <span class="comment">//如果当前规则的限流阈值类型为 THREADS，则返回node统计的当前并行占用的线程数。</span></span><br><span class="line">    <span class="keyword">int</span> curCount = avgUsedTokens(node);</span><br><span class="line">    <span class="comment">//判断加上acquireCount是否超过阈值，超过阈值则拒绝（prioritized除外）</span></span><br><span class="line">    <span class="keyword">if</span> (curCount + acquireCount &gt; count) &#123;</span><br><span class="line">        <span class="comment">//如果限流阈值类型为 QPS且为优先流量，可以占用之后的流量（并非直接执行，需要等待对应时间）</span></span><br><span class="line">        <span class="keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;</span><br><span class="line">            <span class="keyword">long</span> currentTime;</span><br><span class="line">            <span class="keyword">long</span> waitInMs;</span><br><span class="line">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">            <span class="comment">//计算占用之后流量后需要等待的时间（只允许占用1秒）</span></span><br><span class="line">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);</span><br><span class="line">            <span class="comment">//判断是否超过等待最长时间</span></span><br><span class="line">            <span class="keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">                <span class="comment">//允许占用</span></span><br><span class="line">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class="line">                node.addOccupiedPass(acquireCount);</span><br><span class="line">                sleep(waitInMs);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PriorityWaitException(waitInMs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOccupyNext</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">int</span> acquireCount, <span class="keyword">double</span> threshold)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最多可占用令牌数（1s产生的令牌）</span></span><br><span class="line">    <span class="keyword">double</span> maxCount = threshold * IntervalProperty.INTERVAL / <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//当前秒级窗口已经被占用令牌数</span></span><br><span class="line">    <span class="keyword">long</span> currentBorrow = rollingCounterInSecond.waiting();</span><br><span class="line">    <span class="keyword">if</span> (currentBorrow &gt;= maxCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> OccupyTimeoutProperty.getOccupyTimeout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//样本窗口长度</span></span><br><span class="line">    <span class="keyword">int</span> windowLength = IntervalProperty.INTERVAL / SampleCountProperty.SAMPLE_COUNT;</span><br><span class="line">    <span class="comment">//currentTime - currentTime % windowLength 当前时间所在样本窗口开始时间</span></span><br><span class="line">    <span class="comment">//当前窗口开始时间，也是要占用的第一个样本窗口的开始时间</span></span><br><span class="line">    <span class="keyword">long</span> earliestTime = currentTime - currentTime % windowLength + windowLength - IntervalProperty.INTERVAL;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note: here &#123;@code currentPass&#125; may be less than it really is NOW, because time difference</span></span><br><span class="line"><span class="comment">         * since call rollingCounterInSecond.pass(). So in high concurrency, the following code may</span></span><br><span class="line"><span class="comment">         * lead more tokens be borrowed.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="comment">//当前秒级窗口通过的请求数</span></span><br><span class="line">    <span class="keyword">long</span> currentPass = rollingCounterInSecond.pass();</span><br><span class="line">    <span class="keyword">while</span> (earliestTime &lt; currentTime) &#123;</span><br><span class="line">        <span class="comment">//计算等待时间，等待到当前窗口结束（因为一个样本窗口可以存在于多个未来窗口中，当idx为0时，当前样本窗口为当前未来窗口的最后一个样本窗口，为1时当前样本窗口为当前未来窗口的倒数第二个样本窗口）</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *｜--1--｜--2--｜--3--｜</span></span><br><span class="line"><span class="comment">         *idx=0 当前样本窗口为3，等待到结束</span></span><br><span class="line"><span class="comment">         *idx=1 当前样本窗口为2，同样等待到结束，比idx=1时多一个样本窗口时间长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> waitInMs = idx * windowLength + windowLength - currentTime % windowLength;</span><br><span class="line">        <span class="comment">//超时退出</span></span><br><span class="line">        <span class="keyword">if</span> (waitInMs &gt;= OccupyTimeoutProperty.getOccupyTimeout()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//目前所在未来窗口的通过数</span></span><br><span class="line">        <span class="keyword">long</span> windowPass = rollingCounterInSecond.getWindowPass(earliestTime);</span><br><span class="line">        <span class="comment">//当前窗口通过数+当前窗口被占用数+需要的令牌数-目前所在未来窗口的通过数（重复计算所以减去）&lt;=最多可占用令牌数</span></span><br><span class="line">        <span class="keyword">if</span> (currentPass + currentBorrow + acquireCount - windowPass &lt;= maxCount) &#123;</span><br><span class="line">            <span class="keyword">return</span> waitInMs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//占用窗口后移</span></span><br><span class="line">        earliestTime += windowLength;</span><br><span class="line">        currentPass -= windowPass;</span><br><span class="line">        idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OccupyTimeoutProperty.getOccupyTimeout();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ratelimitercontroller">RateLimiterController</h6>
<p>实现排队等待</p>
<blockquote>
<p>设置 QPS 为 10，那么每 100 毫秒允许通过一个，通过计算当前时间是否已经过了上一个请求的通过时间 latestPassedTime 之后的 100 毫秒，来判断是否可以通过。假设才过了 50ms，那么需要当前线程再 sleep 50ms，然后才可以通过。如果同时有另一个请求呢？那需要 sleep 150ms 才行。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Pass when acquire count is less or equal than 0.</span></span><br><span class="line">        <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Reject when count is less or equal than 0.</span></span><br><span class="line">        <span class="comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Calculate the interval between every two requests.</span></span><br><span class="line">        <span class="keyword">long</span> costTime = Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Expected pass time of this request.</span></span><br><span class="line">        <span class="keyword">long</span> expectedTime = costTime + latestPassedTime.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">            <span class="comment">// Contention may exist here, but it's okay.</span></span><br><span class="line">            latestPassedTime.set(currentTime);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Calculate the time to wait.</span></span><br><span class="line">            <span class="keyword">long</span> waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> oldTime = latestPassedTime.addAndGet(costTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                        latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// in race condition waitTime may &lt;= 0</span></span><br><span class="line">                    <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Thread.sleep(waitTime);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="warmupcontroller">WarmUpController</h6>
<p>实现Warm Up</p>
<p>Warm Up，冷启动。在应用升级重启时或长时间低压力之后，应用自身需要一个预热的过程，预热之后才能到达一个稳定的性能状态，比如说，接口预热阶段完成 JIT 即时编译、完成一些单例对象的创建、线程池的创建、各种连接池的初始化、或者执行首次需要加锁执行的代码块。核心算法借鉴了Guava中SmoothWarmingUp的实现，详细分析见<br />
<a href="https://www.javadoop.com/post/rate-limiter" target="_blank" rel="noopener">https://www.javadoop.com/post/rate-limiter</a><br />
<a href="https://www.jianshu.com/p/280bf2dbd6f0" target="_blank" rel="noopener">https://www.jianshu.com/p/280bf2dbd6f0</a>（推荐这篇）</p>
<p>在构造函数中通过double count, int warmUpPeriodInSec, int coldFactor三个参数，计算出warningToken，maxToken，slope</p>
<p>但是由于关注的qps所以对一些变量进行了替换</p>
<ul>
<li>warmupPeriod=warmUpPeriodInSec</li>
<li>stableInterval=1/count</li>
<li>maxPermits=maxToken</li>
<li>thresholdPermits=warningToken</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (coldFactor &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cold factor should be larger than 1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.coldFactor = coldFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// thresholdPermits = 0.5 * warmupPeriod / stableInterval.</span></span><br><span class="line">    <span class="comment">// warningToken = 100;</span></span><br><span class="line">    warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// / maxPermits = thresholdPermits + 2 * warmupPeriod /</span></span><br><span class="line">    <span class="comment">// (stableInterval + coldInterval)</span></span><br><span class="line">    <span class="comment">// maxToken = 200</span></span><br><span class="line">    maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slope</span></span><br><span class="line">    <span class="comment">// slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits</span></span><br><span class="line">    <span class="comment">// - thresholdPermits);</span></span><br><span class="line">    slope = (coldFactor - <span class="number">1.0</span>) / count / (maxToken - warningToken);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过判断计算该点对应的qps阈值，进行判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> passQps = (<span class="keyword">long</span>) node.passQps();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> previousQps = (<span class="keyword">long</span>) node.previousPassQps();</span><br><span class="line">    <span class="comment">//设置 storedTokens 和 lastFilledTime 到正确的值，重新装填令牌桶</span></span><br><span class="line">    syncToken(previousQps);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始计算它的斜率</span></span><br><span class="line">    <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">    <span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line">    <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">        <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line">        <span class="comment">// 消耗的速度要比warning快</span></span><br><span class="line">        <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">        <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncToken</span><span class="params">(<span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">    currentTime = currentTime - currentTime % <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">long</span> oldLastFillTime = lastFilledTime.get();</span><br><span class="line">    <span class="keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="comment">//计算新的令牌数量</span></span><br><span class="line">    <span class="keyword">long</span> newValue = coolDownTokens(currentTime, passQps);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;</span><br><span class="line">        <span class="keyword">long</span> currentValue = storedTokens.addAndGet(<span class="number">0</span> - passQps);</span><br><span class="line">        <span class="keyword">if</span> (currentValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            storedTokens.set(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lastFilledTime.set(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">coolDownTokens</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="keyword">long</span> newValue = oldValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加令牌的判断前提条件:</span></span><br><span class="line">    <span class="comment">// 当令牌的消耗程度远远低于警戒线的时候</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue &lt; warningToken) &#123;</span><br><span class="line">        <span class="comment">//按照每秒count个的速度掉落</span></span><br><span class="line">        newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">//令牌消耗速率大于警戒线</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue &gt; warningToken) &#123;</span><br><span class="line">        <span class="comment">//前一个bucket通过的qps小于阈值/ coldFactor，说明系统消耗令牌的速度，小于冷却速度，需要添加令牌</span></span><br><span class="line">        <span class="keyword">if</span> (passQps &lt; (<span class="keyword">int</span>)count / coldFactor) &#123;</span><br><span class="line">            newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(newValue, maxToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="warmupratelimitercontroller">WarmUpRateLimiterController</h6>
<p>RateLimiterController与WarmUpController的结合</p>
<p>通过WarmUpController中一样的算法计算出当前的qps阈值，再用该阈值去计算等待时间</p>
<h4 id="degradeslot">DegradeSlot</h4>
<p>实现熔断降级的切入点，功能由ProcessorSlot、CircuitBreaker、DegradeRule、DegradeRuleManager组合完成。且经过一次升级，通过状态间的自动转换避免了原版本使用定时器的缺点。</p>
<h5 id="熔断策略">熔断策略</h5>
<ul>
<li>SLOW_REQUEST_RATIO：按慢请求比率</li>
<li>ERROR_RATIO：按失败比率</li>
<li>ERROR_COUNT：按失败次数</li>
</ul>
<p>ExceptionCircuitBreaker实现根据异常比例熔断</p>
<p>ResponseTimeCircuitBreaker实现根据RT时间熔断</p>
<p>slot中通过调用两者的onRequestComplete方法统计并且判断是否熔断的逻辑</p>
<h5 id="熔断器状态">熔断器状态</h5>
<ul>
<li>当熔断器状态为半开启状态时，直接拒绝请求；</li>
<li>当熔断器为关闭状态时，请求被允许通过；</li>
<li>当熔断器状态为开启状态时，根据 timeWindow 尝试将开关状态改为半闭合，如何修改成功，则允许当前请求通过。</li>
</ul>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/ima8ge.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h5 id="详细分析">详细分析</h5>
<p>这一块的实现，内部版本与开源版本略有不同，这边的分析以开源版本为例。</p>
<p>核心方法如下</p>
<p><strong>AbstractCircuitBreaker#tryPass</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryPass</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Template implementation.</span></span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.CLOSED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.OPEN) &#123;</span><br><span class="line">        <span class="comment">// For half-open state we allow a request for probing.</span></span><br><span class="line">        <span class="comment">//熔断器开启状态，判断是否到达可以重试时间并尝试将状态改到半开启</span></span><br><span class="line">        <span class="keyword">return</span> retryTimeoutArrived() &amp;&amp; fromOpenToHalfOpen(context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>AbstractCircuitBreaker#状态转换</strong></p>
<p>基本都是使用CAS机制更改状态并且调用监听</p>
<p>下面展示的是解决一个bug的临时方案</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">fromOpenToHalfOpen</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (currentState.compareAndSet(State.OPEN, State.HALF_OPEN)) &#123;</span><br><span class="line">        notifyObservers(State.OPEN, State.HALF_OPEN, <span class="keyword">null</span>);</span><br><span class="line">        Entry entry = context.getCurEntry();</span><br><span class="line">        entry.whenTerminate(<span class="keyword">new</span> BiConsumer&lt;Context, Entry&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Context context, Entry entry)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// Note: This works as a temporary workaround for https://github.com/alibaba/Sentinel/issues/1638</span></span><br><span class="line">                <span class="comment">// Without the hook, the circuit breaker won't recover from half-open state in some circumstances</span></span><br><span class="line">                <span class="comment">// when the request is actually blocked by upcoming rules (not only degrade rules).</span></span><br><span class="line">                <span class="comment">//为了解决注释中提到的问题，在发生异常后将状态改回open，以防止永久处于half-open状态的bug</span></span><br><span class="line">                <span class="keyword">if</span> (entry.getBlockError() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Fallback to OPEN due to detecting request is blocked</span></span><br><span class="line">                    currentState.compareAndSet(State.HALF_OPEN, State.OPEN);</span><br><span class="line">                    notifyObservers(State.HALF_OPEN, State.OPEN, <span class="number">1.0</span>d);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ExceptionCircuitBreaker#onRequestComplete</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestComplete</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Entry entry = context.getCurEntry();</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Throwable error = entry.getError();</span><br><span class="line">    SimpleErrorCounter counter = stat.currentWindow().value();</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//出现异常，增加异常计数器</span></span><br><span class="line">        counter.getErrorCount().add(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//增加总计数器</span></span><br><span class="line">    counter.getTotalCount().add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    handleStateChangeWhenThresholdExceeded(error);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleStateChangeWhenThresholdExceeded</span><span class="params">(Throwable error)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//熔断器打开直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.OPEN) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//熔断器半开，本次请求如果无异常，关闭熔断器，否则重新打开熔断器</span></span><br><span class="line">    <span class="keyword">if</span> (currentState.get() == State.HALF_OPEN) &#123;</span><br><span class="line">        <span class="comment">// In detecting request</span></span><br><span class="line">        <span class="keyword">if</span> (error == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fromHalfOpenToClose();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fromHalfOpenToOpen(<span class="number">1.0</span>d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//熔断器关闭状态</span></span><br><span class="line">    List&lt;SimpleErrorCounter&gt; counters = stat.values();</span><br><span class="line">    <span class="keyword">long</span> errCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> totalCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (SimpleErrorCounter counter : counters) &#123;</span><br><span class="line">        errCount += counter.errorCount.sum();</span><br><span class="line">        totalCount += counter.totalCount.sum();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//未达到最小请求数，返回</span></span><br><span class="line">    <span class="keyword">if</span> (totalCount &lt; minRequestAmount) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> curCount = errCount;</span><br><span class="line">    <span class="comment">//计算异常比例</span></span><br><span class="line">    <span class="keyword">if</span> (strategy == DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class="line">        <span class="comment">// Use errorRatio</span></span><br><span class="line">        curCount = errCount * <span class="number">1.0</span>d / totalCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//异常比例大于阈值，熔断器打开</span></span><br><span class="line">    <span class="keyword">if</span> (curCount &gt; threshold) &#123;</span><br><span class="line">        transformToOpen(curCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ResponseTimeCircuitBreaker#onRequestComplete</strong></p>
<p>整体类似上一个方法，不再赘述</p>
<h1 id="一些对应关系">一些对应关系</h1>
<p>一个context（context name为唯一标识，context跟着线程走，切换线程需要手动切换）</p>
<ul>
<li>对应 一个调用链路 （默认值为sentinel_default_context）</li>
<li>对应一个 entrancenode（在Context.enter时创建）</li>
</ul>
<p>一个resource （resource name为唯一标识）</p>
<ul>
<li>对应一个责任链实例（共享同一个 NodeSelectorSlot 实例以及 ClusterBuilderSlot实例）</li>
<li>对应一个ClusterNode（不同origin会在该ClusterNode下挂不同的数据节点）</li>
</ul>
<p>一个DefaultNode（维持调用树状结构）</p>
<ul>
<li>对应一个context下的一个resource，即它的纬度是context*resource，存在NodeSelectorSlot的map中（key为context name）</li>
</ul>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/imag9e.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<figure>
<img src="/2021/07/04/Sentinel学习笔记-sentinel-cor/image9.png" alt="" /><figcaption>来源见参考链接</figcaption>
</figure>
<h1 id="举例">举例</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//规则</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initFlowRules</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;FlowRule&gt; rules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    FlowRule rule = <span class="keyword">new</span> FlowRule();</span><br><span class="line">    rule.setResource(<span class="string">"helloAnother"</span>);</span><br><span class="line">    rule.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    <span class="comment">// Set limit QPS to 20.</span></span><br><span class="line">    rule.setCount(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    FlowRule rule2 = <span class="keyword">new</span> FlowRule();</span><br><span class="line">    rule2.setResource(<span class="string">"hello"</span>);</span><br><span class="line">    rule2.setGrade(RuleConstant.FLOW_GRADE_QPS);</span><br><span class="line">    <span class="comment">// Set limit QPS to 2.</span></span><br><span class="line">    rule2.setCount(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    rules.add(rule);</span><br><span class="line">    rules.add(rule2);</span><br><span class="line">    FlowRuleManager.loadRules(rules);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源hello</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"hello"</span>, fallback = <span class="string">"helloFallback"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"invalid arg"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">"Hello at %d"</span>, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//资源helloAnother</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@SentinelResource</span>(value = <span class="string">"helloAnother"</span>, defaultFallback = <span class="string">"defaultFallback"</span>,</span><br><span class="line">                  exceptionsToIgnore = &#123;IllegalStateException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">String</span> <span class="title">helloAnother</span>(<span class="title">String</span> <span class="title">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || <span class="string">"bad"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"oops"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"foo"</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"oops"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String temp=testService.hello(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Hello, "</span> + name + <span class="string">" "</span> + temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> interval=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length==<span class="number">0</span>)&#123;</span><br><span class="line">            interval=<span class="number">100</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            Float qps=Float.parseFloat(args[<span class="number">0</span>]);</span><br><span class="line">            interval=Math.round(<span class="number">1000</span>/qps);</span><br><span class="line">        &#125;</span><br><span class="line">        doTest(interval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTest</span><span class="params">(<span class="keyword">int</span> interval)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(interval);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                firstLevel();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                System.out.println(e.getMessage() + <span class="string">" block"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">firstLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">        <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"firstLevel"</span>, EntryType.IN))&#123;</span><br><span class="line">            <span class="keyword">if</span> (count%(interval*<span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"firstLevel"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            secondLevel();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"firstLevel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">secondLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ContextUtil.enter(<span class="string">"level-test"</span>,<span class="string">"application"</span>);</span><br><span class="line">        <span class="keyword">try</span> (Entry entry = SphU.entry(<span class="string">"secondLevel"</span>,EntryType.OUT))&#123;</span><br><span class="line">            <span class="keyword">if</span> (count%(interval*<span class="number">5</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"secondLevel"</span>);</span><br><span class="line">                count=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"secondLevel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考链接">参考链接</h1>
<p><a href="https://github.com/sentinel-group/sentinel-awesome" target="_blank" rel="noopener">https://github.com/sentinel-group/sentinel-awesome</a></p>
<p><a href="https://www.javadoop.com/post/sentinel" target="_blank" rel="noopener">https://www.javadoop.com/post/sentinel</a></p>
<p><a href="http://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Sentinel%EF%BC%88%E5%AE%8C%EF%BC%89/01%20%E5%BC%80%E7%AF%87%E8%AF%8D%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E7%BB%8F%E5%8E%86.md" target="_blank" rel="noopener">http://learn.lianglianglee.com/</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" rel="tag"># 源码分析</a>
          
            <a href="/tags/Sentinel/" rel="tag"># Sentinel</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/01/13/%E5%B9%B6%E6%9F%A5%E9%9B%86/" rel="next" title="并查集">
                <i class="fa fa-chevron-left"></i> 并查集
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/10/Sentinel%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-sentinel-cluster/" rel="prev" title="Sentinel学习笔记:sentinel-cluster">
                Sentinel学习笔记:sentinel-cluster <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="gitalk-container">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="Arvin" />
            
              <p class="site-author-name" itemprop="name">Arvin</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#有的没的"><span class="nav-number">1.</span> <span class="nav-text">有的没的</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#经典限流算法"><span class="nav-number">2.</span> <span class="nav-text">经典限流算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#计数器算法"><span class="nav-number">2.1.</span> <span class="nav-text">计数器算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#漏桶算法leaky-bucket"><span class="nav-number">2.2.</span> <span class="nav-text">漏桶算法（Leaky Bucket）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#令牌桶算法token-bucket"><span class="nav-number">2.3.</span> <span class="nav-text">令牌桶算法（Token Bucket）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据模型"><span class="nav-number">3.</span> <span class="nav-text">数据模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#核心类"><span class="nav-number">3.1.</span> <span class="nav-text">核心类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#arraymetric"><span class="nav-number">3.1.1.</span> <span class="nav-text">ArrayMetric</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#leaparray"><span class="nav-number">3.1.2.</span> <span class="nav-text">LeapArray</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#windowwrap"><span class="nav-number">3.1.3.</span> <span class="nav-text">WindowWrap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#metricbucket"><span class="nav-number">3.1.4.</span> <span class="nav-text">MetricBucket</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#核心方法"><span class="nav-number">3.2.</span> <span class="nav-text">核心方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取数据以success为例"><span class="nav-number">3.2.1.</span> <span class="nav-text">获取数据（以success为例）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增加数据以addsuccess为例"><span class="nav-number">3.2.2.</span> <span class="nav-text">增加数据（以addSuccess为例）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#滑动窗口类型"><span class="nav-number">3.3.</span> <span class="nav-text">滑动窗口类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分钟级滑动窗口"><span class="nav-number">3.3.1.</span> <span class="nav-text">分钟级滑动窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#秒级滑动窗口"><span class="nav-number">3.3.2.</span> <span class="nav-text">秒级滑动窗口</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#切入流程"><span class="nav-number">4.</span> <span class="nav-text">切入流程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通过aop机制织入"><span class="nav-number">4.1.</span> <span class="nav-text">通过AOP机制织入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#entry"><span class="nav-number">4.2.</span> <span class="nav-text">Entry</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#核心类-1"><span class="nav-number">5.</span> <span class="nav-text">核心类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#context"><span class="nav-number">5.1.</span> <span class="nav-text">Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#entry-1"><span class="nav-number">5.2.</span> <span class="nav-text">Entry</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node"><span class="nav-number">5.3.</span> <span class="nav-text">Node</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#statisticnode"><span class="nav-number">5.3.1.</span> <span class="nav-text">StatisticNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#defaultnode"><span class="nav-number">5.3.2.</span> <span class="nav-text">DefaultNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#entrancenode"><span class="nav-number">5.3.3.</span> <span class="nav-text">EntranceNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clusternode"><span class="nav-number">5.3.4.</span> <span class="nav-text">ClusterNode</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#root与调用树"><span class="nav-number">5.4.</span> <span class="nav-text">Root与调用树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#slot"><span class="nav-number">5.5.</span> <span class="nav-text">Slot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据统计slot"><span class="nav-number">5.5.1.</span> <span class="nav-text">数据统计Slot</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#nodeselectorslot"><span class="nav-number">5.5.1.1.</span> <span class="nav-text">NodeSelectorSlot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clusterbuilderslot"><span class="nav-number">5.5.1.2.</span> <span class="nav-text">ClusterBuilderSlot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#logslot"><span class="nav-number">5.5.1.3.</span> <span class="nav-text">LogSlot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#statisticslot"><span class="nav-number">5.5.1.4.</span> <span class="nav-text">StatisticSlot</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#entry-方法"><span class="nav-number">5.5.1.4.1.</span> <span class="nav-text">entry 方法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#请求正常通过"><span class="nav-number">5.5.1.4.1.1.</span> <span class="nav-text">请求正常通过</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#捕获prioritywaitexception异常"><span class="nav-number">5.5.1.4.1.2.</span> <span class="nav-text">捕获PriorityWaitException异常</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#捕获到-blockexception-异常"><span class="nav-number">5.5.1.4.1.3.</span> <span class="nav-text">捕获到 BlockException 异常</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#捕获到其他异常"><span class="nav-number">5.5.1.4.1.4.</span> <span class="nav-text">捕获到其他异常</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#exit-方法"><span class="nav-number">5.5.1.4.2.</span> <span class="nav-text">exit 方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限流降级以及流控slot"><span class="nav-number">5.5.2.</span> <span class="nav-text">限流降级以及流控Slot</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#authorityslot"><span class="nav-number">5.5.2.1.</span> <span class="nav-text">AuthoritySlot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#systemslot"><span class="nav-number">5.5.2.2.</span> <span class="nav-text">SystemSlot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#flowslot"><span class="nav-number">5.5.2.3.</span> <span class="nav-text">FlowSlot</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#trafficshapingcontroller"><span class="nav-number">5.5.2.3.1.</span> <span class="nav-text">TrafficShapingController</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#defaultcontroller"><span class="nav-number">5.5.2.3.1.1.</span> <span class="nav-text">DefaultController</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ratelimitercontroller"><span class="nav-number">5.5.2.3.1.2.</span> <span class="nav-text">RateLimiterController</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#warmupcontroller"><span class="nav-number">5.5.2.3.1.3.</span> <span class="nav-text">WarmUpController</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#warmupratelimitercontroller"><span class="nav-number">5.5.2.3.1.4.</span> <span class="nav-text">WarmUpRateLimiterController</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#degradeslot"><span class="nav-number">5.5.2.4.</span> <span class="nav-text">DegradeSlot</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#熔断策略"><span class="nav-number">5.5.2.4.1.</span> <span class="nav-text">熔断策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#熔断器状态"><span class="nav-number">5.5.2.4.2.</span> <span class="nav-text">熔断器状态</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#详细分析"><span class="nav-number">5.5.2.4.3.</span> <span class="nav-text">详细分析</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#一些对应关系"><span class="nav-number">6.</span> <span class="nav-text">一些对应关系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#举例"><span class="nav-number">7.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#参考链接"><span class="nav-number">8.</span> <span class="nav-text">参考链接</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arvin</span>
  <span class="contact">
    <a href="mailto:someone@example.com">arvinfield1998@outlook.com</a>
  </span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>
  <div class="check-info">
    <a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=33090202000449" style="display:inline-block;text-decoration:none;height:20px;line-height:20px;"><img src="/uploads/1.png" style="float:left;"/><p style="float:left;height:20px;line-height:20px;margin: 0px 0px 0px 5px; color:#939393;">浙公网安备 33090202000449号</p></a>
  </div>
		 



		 
        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  











<!--
  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <script src="/js/src/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: '',
      clientSecret: '',
      repo: 'github-pages-comments',
      owner: '',
      admin: [''],
      id: location.pathname,
      id: md5(location.pathname),
      distractionFreeMode: 'false'
    })
    gitalk.render('gitalk-container')
  </script>
-->



  <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
  <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
  <div id="gitalk-container"></div>
  <script src="/js/src/md5.min.js"></script>
  <script type="text/javascript">
    var gitalk = new Gitalk({
      clientID: 'cb2e7201cbc8c531d2e2',
      clientSecret: 'c5d11683241ac9caffe2b491c39b17813bbb06ad',
      repo: 'github-pages-comments',
      owner: 'LearningGp',
      admin: ['LearningGp'],
      id: md5(location.pathname),
      distractionFreeMode: 'false'
    })
    gitalk.render('gitalk-container')
  </script>

  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->





  

  

  

  
  

  
  


  

  

</body>
</html>
